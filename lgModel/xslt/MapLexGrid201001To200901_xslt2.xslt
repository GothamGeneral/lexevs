<?xml version="1.0" encoding="UTF-8"?>
<!--
This file was generated by Altova MapForce 2011

YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.

Refer to the Altova MapForce Documentation for further details.
http://www.altova.com/mapforce
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ns0="http://LexGrid.org/schema/2010/01/LexGrid/codingSchemes" xmlns:ns1="http://LexGrid.org/schema/2010/01/LexGrid/commonTypes" xmlns:ns2="http://LexGrid.org/schema/2010/01/LexGrid/concepts" xmlns:ns3="http://LexGrid.org/schema/2010/01/LexGrid/naming" xmlns:ns4="http://LexGrid.org/schema/2010/01/LexGrid/valueSets" xmlns:ns5="http://LexGrid.org/schema/2010/01/LexGrid/versions" xmlns:core="http://www.altova.com/MapForce/UDF/core" xmlns:tbf="http://www.altova.com/MapForce/UDF/tbf" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" exclude-result-prefixes="ns0 ns1 ns2 ns3 ns4 ns5 core tbf xs fn">
	<xsl:template name="core:convert-uri-to-windows-file-path">
		<xsl:param name="uri" select="()"/>
		<xsl:choose>
			<xsl:when test="fn:starts-with($uri, 'file://')">
				<xsl:choose>
					<xsl:when test="(fn:substring($uri, xs:double('6'), xs:double('3')) = '///')">
						<xsl:variable name="var1_resultof_url_decode" as="xs:string">
							<xsl:call-template name="core:url-decode">
								<xsl:with-param name="uri" select="fn:substring($uri, xs:double('9'), xs:double(fn:string-length($uri)))" as="xs:string"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:sequence select="(fn:translate($var1_resultof_url_decode, '/|', '\:'))"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:sequence select="($uri)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="($uri)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="core:url-decode">
		<xsl:param name="uri" select="()"/>
		<xsl:choose>
			<xsl:when test="fn:contains($uri, '%')">
				<xsl:variable name="var1_resultof_url_decode_part" as="xs:string">
					<xsl:call-template name="core:url-decode-part">
						<xsl:with-param name="uripart" select="fn:substring-after($uri, '%')" as="xs:string"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:sequence select="(fn:concat(fn:substring-before($uri, '%'), $var1_resultof_url_decode_part))"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="($uri)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="core:url-decode-part">
		<xsl:param name="uripart" select="()"/>
		<xsl:variable name="var1_resultof_dec_from__digits_hex" as="xs:decimal">
			<xsl:call-template name="core:dec-from-2digits-hex">
				<xsl:with-param name="hex" select="$uripart" as="xs:string"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="($var1_resultof_dec_from__digits_hex &lt; xs:decimal('128'))">
				<xsl:call-template name="core:url-decode-utf8">
					<xsl:with-param name="value" select="$var1_resultof_dec_from__digits_hex" as="xs:decimal"/>
					<xsl:with-param name="bytes" select="xs:decimal('0')" as="xs:decimal"/>
					<xsl:with-param name="rest" select="fn:substring($uripart, xs:double('3'), xs:double(fn:string-length($uripart)))" as="xs:string"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="($var1_resultof_dec_from__digits_hex &lt; xs:decimal('194'))">
						<xsl:call-template name="core:url-decode">
							<xsl:with-param name="uri" select="fn:substring($uripart, xs:double('3'), xs:double(fn:string-length($uripart)))" as="xs:string"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:choose>
							<xsl:when test="($var1_resultof_dec_from__digits_hex &lt; xs:decimal('224'))">
								<xsl:call-template name="core:url-decode-utf8">
									<xsl:with-param name="value" select="$var1_resultof_dec_from__digits_hex" as="xs:decimal"/>
									<xsl:with-param name="bytes" select="xs:decimal('1')" as="xs:decimal"/>
									<xsl:with-param name="rest" select="fn:substring($uripart, xs:double('3'), xs:double(fn:string-length($uripart)))" as="xs:string"/>
								</xsl:call-template>
							</xsl:when>
							<xsl:otherwise>
								<xsl:choose>
									<xsl:when test="($var1_resultof_dec_from__digits_hex &lt; xs:decimal('240'))">
										<xsl:call-template name="core:url-decode-utf8">
											<xsl:with-param name="value" select="$var1_resultof_dec_from__digits_hex" as="xs:decimal"/>
											<xsl:with-param name="bytes" select="xs:decimal('2')" as="xs:decimal"/>
											<xsl:with-param name="rest" select="fn:substring($uripart, xs:double('3'), xs:double(fn:string-length($uripart)))" as="xs:string"/>
										</xsl:call-template>
									</xsl:when>
									<xsl:otherwise>
										<xsl:choose>
											<xsl:when test="($var1_resultof_dec_from__digits_hex &lt; xs:decimal('245'))">
												<xsl:call-template name="core:url-decode-utf8">
													<xsl:with-param name="value" select="$var1_resultof_dec_from__digits_hex" as="xs:decimal"/>
													<xsl:with-param name="bytes" select="xs:decimal('3')" as="xs:decimal"/>
													<xsl:with-param name="rest" select="fn:substring($uripart, xs:double('3'), xs:double(fn:string-length($uripart)))" as="xs:string"/>
												</xsl:call-template>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="('')"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="core:dec-from-2digits-hex">
		<xsl:param name="hex" select="()"/>
		<xsl:variable name="var1_resultof_dec_from__digit_hex" as="xs:decimal">
			<xsl:call-template name="core:dec-from-1digit-hex">
				<xsl:with-param name="hex" select="fn:substring($hex, xs:double('1'), xs:double('1'))" as="xs:string"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="var2_resultof_dec_from__digit_hex" as="xs:decimal">
			<xsl:call-template name="core:dec-from-1digit-hex">
				<xsl:with-param name="hex" select="fn:substring($hex, xs:double('2'), xs:double('1'))" as="xs:string"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:sequence select="(($var1_resultof_dec_from__digit_hex * xs:decimal('16')) + $var2_resultof_dec_from__digit_hex)"/>
	</xsl:template>
	<xsl:template name="core:url-decode-utf8">
		<xsl:param name="value" select="()"/>
		<xsl:param name="bytes" select="()"/>
		<xsl:param name="rest" select="()"/>
		<xsl:choose>
			<xsl:when test="($bytes = xs:integer('0'))">
				<xsl:variable name="var1_resultof_char_from_code" as="xs:string">
					<xsl:call-template name="core:char-from-code">
						<xsl:with-param name="code" select="xs:integer($value)" as="xs:integer"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="var2_resultof_url_decode" as="xs:string">
					<xsl:call-template name="core:url-decode">
						<xsl:with-param name="uri" select="$rest" as="xs:string"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:sequence select="(fn:concat($var1_resultof_char_from_code, $var2_resultof_url_decode))"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="(fn:substring($rest, xs:double('1'), xs:double('1')) = '%')">
						<xsl:variable name="var3_resultof_dec_from__digits_hex" as="xs:decimal">
							<xsl:call-template name="core:dec-from-2digits-hex">
								<xsl:with-param name="hex" select="fn:substring($rest, xs:double('2'), xs:double(fn:string-length($rest)))" as="xs:string"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:call-template name="core:url-decode-utf8">
							<xsl:with-param name="value" select="((($value mod xs:decimal('64')) * xs:decimal('64')) + ($var3_resultof_dec_from__digits_hex mod xs:decimal('64')))" as="xs:decimal"/>
							<xsl:with-param name="bytes" select="($bytes - xs:decimal('1'))" as="xs:decimal"/>
							<xsl:with-param name="rest" select="fn:substring($rest, xs:double('4'), xs:double(fn:string-length($rest)))" as="xs:string"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="core:url-decode">
							<xsl:with-param name="uri" select="$rest" as="xs:string"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="core:dec-from-1digit-hex">
		<xsl:param name="hex" select="()"/>
		<xsl:variable name="var1_resultof_string_length" as="xs:integer" select="fn:string-length(fn:substring-before('0123456789ABCDEFabcdef', $hex))"/>
		<xsl:choose>
			<xsl:when test="($var1_resultof_string_length &lt;= xs:integer('15'))">
				<xsl:sequence select="($var1_resultof_string_length)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="(($var1_resultof_string_length - xs:decimal('6')))"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="core:char-from-code">
		<xsl:param name="code" select="()"/>
		<xsl:sequence select="fn:codepoints-to-string($code)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf1_entryState">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@containingRevision">
			<xsl:attribute name="containingRevision" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@relativeOrder">
			<xsl:attribute name="relativeOrder" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@changeType">
			<xsl:attribute name="changeType" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@prevRevision">
			<xsl:attribute name="prevRevision" select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf2_source">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@subRef">
			<xsl:attribute name="subRef" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@role">
			<xsl:attribute name="role" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf3_supportedAssociationQualifier">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf4_supportedCodingScheme">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@isImported">
			<xsl:attribute name="isImported" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf5_supportedContainerName">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf6_supportedContext">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf7_supportedDataType">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf8_supportedDegreeOfFidelity">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf9_supportedEntityType">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf10_supportedHierarchy">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@associationNames">
			<xsl:attribute name="associationNames" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@rootCode">
			<xsl:attribute name="rootCode" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@isForwardNavigable">
			<xsl:attribute name="isForwardNavigable" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf11_supportedLanguage">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf12_supportedNamespace">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@equivalentCodingScheme">
			<xsl:attribute name="equivalentCodingScheme" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf13_supportedPropertyType">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf14_supportedPropertyLink">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf15_supportedPropertyQualifier">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf16_supportedPropertyQualifierType">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf17_supportedRepresentationalForm">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf18_supportedSortOrder">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf19_supportedSource">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@assemblyRule">
			<xsl:attribute name="assemblyRule" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf20_supportedSourceRole">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf21_supportedStatus">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@localId">
			<xsl:attribute name="localId" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@uri">
			<xsl:attribute name="uri" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf22_propertyLink">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@sourceProperty">
			<xsl:attribute name="sourceProperty" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@propertyLink">
			<xsl:attribute name="propertyLink" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@targetProperty">
			<xsl:attribute name="targetProperty" select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf23_text">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@dataType">
			<xsl:attribute name="dataType" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf24_entityReference">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@entityCode">
			<xsl:attribute name="entityCode" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@entityCodeNamespace">
			<xsl:attribute name="entityCodeNamespace" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@referenceAssociation">
			<xsl:attribute name="referenceAssociation" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@transitiveClosure">
			<xsl:attribute name="transitiveClosure" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@leafOnly">
			<xsl:attribute name="leafOnly" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@targetToSource">
			<xsl:attribute name="targetToSource" select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf25_codingSchemeReference">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@codingScheme">
			<xsl:attribute name="codingScheme" select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf26_pickListEntryExclusion">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@entityCode">
			<xsl:attribute name="entityCode" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@entityCodeNamespace">
			<xsl:attribute name="entityCodeNamespace" select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<xsl:template match="/">
		<xsl:variable name="var225_let" as="node()">
			<systemRelease xmlns="http://LexGrid.org/schema/2009/01/LexGrid/versions" xmlns:lgBuiltin="http://LexGrid.org/schema/2009/01/LexGrid/builtins" xmlns:lgCS="http://LexGrid.org/schema/2009/01/LexGrid/codingSchemes" xmlns:lgCommon="http://LexGrid.org/schema/2009/01/LexGrid/commonTypes" xmlns:lgCon="http://LexGrid.org/schema/2009/01/LexGrid/concepts" xmlns:lgNaming="http://LexGrid.org/schema/2009/01/LexGrid/naming" xmlns:lgRel="http://LexGrid.org/schema/2009/01/LexGrid/relations" xmlns:lgVD="http://LexGrid.org/schema/2009/01/LexGrid/valueDomains">
				<xsl:attribute name="xsi:schemaLocation" namespace="http://www.w3.org/2001/XMLSchema-instance" select="'http://LexGrid.org/schema/2009/01/LexGrid/versions C:/DOCUME~1/m039830/MYDOCU~1/Projects/NCI-LE~1.0/XML/2009/schema_2009_01/codingSchemes.xsd'"/>
				<xsl:for-each select="ns5:systemRelease">
					<xsl:variable name="var2_basedOnRelease" as="item()*" select="@basedOnRelease"/>
					<xsl:variable name="var3_releaseAgency" as="item()*" select="@releaseAgency"/>
					<xsl:variable name="var4_releaseId" as="item()*" select="@releaseId"/>
					<xsl:if test="fn:exists($var4_releaseId)">
						<xsl:attribute name="releaseId" namespace="" select="fn:string($var4_releaseId)"/>
					</xsl:if>
					<xsl:attribute name="releaseURI" namespace="" select="xs:string(xs:anyURI(fn:string(@releaseURI)))"/>
					<xsl:attribute name="releaseDate" namespace="" select="xs:string(xs:dateTime(fn:string(@releaseDate)))"/>
					<xsl:if test="fn:exists($var3_releaseAgency)">
						<xsl:attribute name="releaseAgency" namespace="" select="xs:string(xs:anyURI(fn:string($var3_releaseAgency)))"/>
					</xsl:if>
					<xsl:if test="fn:exists($var2_basedOnRelease)">
						<xsl:attribute name="basedOnRelease" namespace="" select="xs:string(xs:anyURI(fn:string($var2_basedOnRelease)))"/>
					</xsl:if>
					<xsl:for-each select="ns1:entityDescription">
						<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
							<xsl:for-each select="node()[fn:boolean(self::text())]">
								<xsl:sequence select="fn:string(.)"/>
							</xsl:for-each>
						</lgCommon:entityDescription>
					</xsl:for-each>
					<xsl:for-each select="ns5:codingSchemes">
						<codingSchemes>
							<xsl:for-each select="ns0:codingScheme">
								<xsl:variable name="var5_status" as="item()*" select="@status"/>
								<xsl:variable name="var6_isActive" as="item()*" select="@isActive"/>
								<xsl:variable name="var7_formalName" as="item()*" select="@formalName"/>
								<xsl:variable name="var8_expirationDate" as="item()*" select="@expirationDate"/>
								<xsl:variable name="var9_approxNumConcepts" as="item()*" select="@approxNumConcepts"/>
								<xsl:variable name="var10_effectiveDate" as="item()*" select="@effectiveDate"/>
								<xsl:variable name="var11_defaultLanguage" as="item()*" select="@defaultLanguage"/>
								<xsl:variable name="var12_mappings" as="node()" select="ns0:mappings"/>
								<lgCS:codingScheme xsl:exclude-result-prefixes="lgCS">
									<xsl:if test="fn:exists($var6_isActive)">
										<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var6_isActive)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var5_status)">
										<xsl:attribute name="status" namespace="" select="fn:string($var5_status)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var10_effectiveDate)">
										<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var10_effectiveDate)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var8_expirationDate)">
										<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var8_expirationDate)))"/>
									</xsl:if>
									<xsl:attribute name="codingSchemeName" namespace="" select="fn:string(@codingSchemeName)"/>
									<xsl:attribute name="codingSchemeURI" namespace="" select="xs:string(xs:anyURI(fn:string(@codingSchemeURI)))"/>
									<xsl:if test="fn:exists($var7_formalName)">
										<xsl:attribute name="formalName" namespace="" select="fn:string($var7_formalName)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var11_defaultLanguage)">
										<xsl:attribute name="defaultLanguage" namespace="" select="fn:string($var11_defaultLanguage)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var9_approxNumConcepts)">
										<xsl:attribute name="approxNumConcepts" namespace="" select="xs:string(xs:integer(fn:string($var9_approxNumConcepts)))"/>
									</xsl:if>
									<xsl:attribute name="representsVersion" namespace="" select="fn:string(@representsVersion)"/>
									<xsl:for-each select="ns1:owner">
										<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
											<xsl:sequence select="fn:string(.)"/>
										</lgCommon:owner>
									</xsl:for-each>
									<xsl:for-each select="ns1:entryState">
										<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
											<xsl:call-template name="tbf:tbf1_entryState">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</lgCommon:entryState>
									</xsl:for-each>
									<xsl:for-each select="ns1:entityDescription">
										<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
											<xsl:for-each select="node()[fn:boolean(self::text())]">
												<xsl:sequence select="fn:string(.)"/>
											</xsl:for-each>
										</lgCommon:entityDescription>
									</xsl:for-each>
									<xsl:for-each select="ns0:localName">
										<lgCS:localName xsl:exclude-result-prefixes="lgCS">
											<xsl:sequence select="fn:string(.)"/>
										</lgCS:localName>
									</xsl:for-each>
									<xsl:for-each select="ns0:source">
										<lgCS:source xsl:exclude-result-prefixes="lgCS">
											<xsl:call-template name="tbf:tbf2_source">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</lgCS:source>
									</xsl:for-each>
									<xsl:for-each select="ns0:copyright">
										<xsl:variable name="var13_dataType" as="item()*" select="@dataType"/>
										<lgCS:copyright xsl:exclude-result-prefixes="lgCS">
											<xsl:if test="fn:exists($var13_dataType)">
												<xsl:attribute name="dataType" namespace="" select="fn:string($var13_dataType)"/>
											</xsl:if>
											<xsl:for-each select="node()[fn:boolean(self::text())]">
												<xsl:sequence select="fn:string(.)"/>
											</xsl:for-each>
										</lgCS:copyright>
									</xsl:for-each>
									<lgCS:mappings xsl:exclude-result-prefixes="lgCS">
										<xsl:for-each select="$var12_mappings/ns3:supportedAssociation">
											<xsl:variable name="var14_uri" as="item()*" select="@uri"/>
											<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
												<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
												<xsl:if test="fn:exists($var14_uri)">
													<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var14_uri)))"/>
												</xsl:if>
												<xsl:sequence select="fn:string(.)"/>
											</lgNaming:supportedAssociation>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedAssociationQualifier">
											<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedAssociationQualifier>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedCodingScheme">
											<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedCodingScheme>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedContainerName">
											<lgNaming:supportedContainer xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf5_supportedContainerName">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedContainer>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedContext">
											<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf6_supportedContext">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedContext>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedDataType">
											<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf7_supportedDataType">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedDataType>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedDegreeOfFidelity">
											<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedDegreeOfFidelity>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedEntityType">
											<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf9_supportedEntityType">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedEntityType>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedHierarchy">
											<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf10_supportedHierarchy">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedHierarchy>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedLanguage">
											<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf11_supportedLanguage">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedLanguage>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedNamespace">
											<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf12_supportedNamespace">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedNamespace>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedProperty">
											<xsl:variable name="var15_uri" as="item()*" select="@uri"/>
											<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
												<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
												<xsl:if test="fn:exists($var15_uri)">
													<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var15_uri)))"/>
												</xsl:if>
												<xsl:sequence select="fn:string(.)"/>
											</lgNaming:supportedProperty>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedPropertyType">
											<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf13_supportedPropertyType">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedPropertyType>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedPropertyLink">
											<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedPropertyLink>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedPropertyQualifier">
											<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedPropertyQualifier>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedPropertyQualifierType">
											<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedPropertyQualifierType>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedRepresentationalForm">
											<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedRepresentationalForm>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedSortOrder">
											<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf18_supportedSortOrder">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedSortOrder>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedSource">
											<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf19_supportedSource">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedSource>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedSourceRole">
											<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf20_supportedSourceRole">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedSourceRole>
										</xsl:for-each>
										<xsl:for-each select="$var12_mappings/ns3:supportedStatus">
											<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
												<xsl:call-template name="tbf:tbf21_supportedStatus">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</lgNaming:supportedStatus>
										</xsl:for-each>
									</lgCS:mappings>
									<xsl:for-each select="ns0:properties">
										<lgCS:properties xsl:exclude-result-prefixes="lgCS">
											<xsl:for-each select="ns1:property">
												<xsl:variable name="var16_isActive" as="item()*" select="@isActive"/>
												<xsl:variable name="var17_effectiveDate" as="item()*" select="@effectiveDate"/>
												<xsl:variable name="var18_language" as="item()*" select="@language"/>
												<xsl:variable name="var19_status" as="item()*" select="@status"/>
												<xsl:variable name="var20_propertyId" as="item()*" select="@propertyId"/>
												<xsl:variable name="var21_propertyType" as="item()*" select="@propertyType"/>
												<xsl:variable name="var22_expirationDate" as="item()*" select="@expirationDate"/>
												<lgCommon:property xsl:exclude-result-prefixes="lgCommon">
													<xsl:if test="fn:exists($var16_isActive)">
														<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var16_isActive)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var19_status)">
														<xsl:attribute name="status" namespace="" select="fn:string($var19_status)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var17_effectiveDate)">
														<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var17_effectiveDate)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var22_expirationDate)">
														<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var22_expirationDate)))"/>
													</xsl:if>
													<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
													<xsl:if test="fn:exists($var20_propertyId)">
														<xsl:attribute name="propertyId" namespace="" select="fn:string($var20_propertyId)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var21_propertyType)">
														<xsl:attribute name="propertyType" namespace="" select="fn:string($var21_propertyType)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var18_language)">
														<xsl:attribute name="language" namespace="" select="fn:string($var18_language)"/>
													</xsl:if>
													<xsl:for-each select="ns1:owner">
														<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:owner>
													</xsl:for-each>
													<xsl:for-each select="ns1:entryState">
														<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf1_entryState">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:entryState>
													</xsl:for-each>
													<xsl:for-each select="ns1:source">
														<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf2_source">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:source>
													</xsl:for-each>
													<xsl:for-each select="ns1:usageContext">
														<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:usageContext>
													</xsl:for-each>
													<xsl:for-each select="ns1:propertyQualifier">
														<xsl:variable name="var23_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
														<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
															<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
															<xsl:if test="fn:exists($var23_propertyQualifierType)">
																<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var23_propertyQualifierType)"/>
															</xsl:if>
															<xsl:for-each select="ns1:value">
																<xsl:variable name="var24_dataType" as="item()*" select="@dataType"/>
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var24_dataType)">
																		<xsl:attribute name="dataType" namespace="" select="fn:string($var24_dataType)"/>
																	</xsl:if>
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:value>
															</xsl:for-each>
														</lgCommon:propertyQualifier>
													</xsl:for-each>
													<xsl:for-each select="ns1:value">
														<xsl:variable name="var25_dataType" as="item()*" select="@dataType"/>
														<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
															<xsl:if test="fn:exists($var25_dataType)">
																<xsl:attribute name="dataType" namespace="" select="fn:string($var25_dataType)"/>
															</xsl:if>
															<xsl:for-each select="node()[fn:boolean(self::text())]">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</lgCommon:value>
													</xsl:for-each>
												</lgCommon:property>
											</xsl:for-each>
										</lgCS:properties>
									</xsl:for-each>
									<xsl:for-each select="ns0:entities">
										<lgCS:entities xsl:exclude-result-prefixes="lgCS">
											<xsl:for-each select="ns2:entity">
												<xsl:variable name="var26_isDefined" as="item()*" select="@isDefined"/>
												<xsl:variable name="var27_isActive" as="item()*" select="@isActive"/>
												<xsl:variable name="var28_entityCodeNamespace" as="item()*" select="@entityCodeNamespace"/>
												<xsl:variable name="var29_isAnonymous" as="item()*" select="@isAnonymous"/>
												<xsl:variable name="var30_effectiveDate" as="item()*" select="@effectiveDate"/>
												<xsl:variable name="var31_status" as="item()*" select="@status"/>
												<xsl:variable name="var32_expirationDate" as="item()*" select="@expirationDate"/>
												<lgCon:entity xsl:exclude-result-prefixes="lgCon">
													<xsl:if test="fn:exists($var27_isActive)">
														<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var27_isActive)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var31_status)">
														<xsl:attribute name="status" namespace="" select="fn:string($var31_status)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var30_effectiveDate)">
														<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var30_effectiveDate)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var32_expirationDate)">
														<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var32_expirationDate)))"/>
													</xsl:if>
													<xsl:attribute name="entityCode" namespace="" select="fn:string(@entityCode)"/>
													<xsl:if test="fn:exists($var28_entityCodeNamespace)">
														<xsl:attribute name="entityCodeNamespace" namespace="" select="fn:string($var28_entityCodeNamespace)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var29_isAnonymous)">
														<xsl:attribute name="isAnonymous" namespace="" select="xs:string(xs:boolean(fn:string($var29_isAnonymous)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var26_isDefined)">
														<xsl:attribute name="isDefined" namespace="" select="xs:string(xs:boolean(fn:string($var26_isDefined)))"/>
													</xsl:if>
													<xsl:for-each select="ns1:owner">
														<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:owner>
													</xsl:for-each>
													<xsl:for-each select="ns1:entryState">
														<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf1_entryState">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:entryState>
													</xsl:for-each>
													<xsl:for-each select="ns1:entityDescription">
														<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
															<xsl:for-each select="node()[fn:boolean(self::text())]">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</lgCommon:entityDescription>
													</xsl:for-each>
													<xsl:for-each select="ns2:entityType">
														<lgCon:entityType xsl:exclude-result-prefixes="lgCon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCon:entityType>
													</xsl:for-each>
													<xsl:for-each select="ns2:presentation">
														<xsl:variable name="var33_language" as="item()*" select="@language"/>
														<xsl:variable name="var34_isPreferred" as="item()*" select="@isPreferred"/>
														<xsl:variable name="var35_effectiveDate" as="item()*" select="@effectiveDate"/>
														<xsl:variable name="var36_matchIfNoContext" as="item()*" select="@matchIfNoContext"/>
														<xsl:variable name="var37_propertyId" as="item()*" select="@propertyId"/>
														<xsl:variable name="var38_status" as="item()*" select="@status"/>
														<xsl:variable name="var39_propertyType" as="item()*" select="@propertyType"/>
														<xsl:variable name="var40_expirationDate" as="item()*" select="@expirationDate"/>
														<xsl:variable name="var41_degreeOfFidelity" as="item()*" select="@degreeOfFidelity"/>
														<xsl:variable name="var42_representationalForm" as="item()*" select="@representationalForm"/>
														<xsl:variable name="var43_isActive" as="item()*" select="@isActive"/>
														<lgCon:presentation xsl:exclude-result-prefixes="lgCon">
															<xsl:if test="fn:exists($var43_isActive)">
																<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var43_isActive)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var38_status)">
																<xsl:attribute name="status" namespace="" select="fn:string($var38_status)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var35_effectiveDate)">
																<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var35_effectiveDate)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var40_expirationDate)">
																<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var40_expirationDate)))"/>
															</xsl:if>
															<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
															<xsl:if test="fn:exists($var37_propertyId)">
																<xsl:attribute name="propertyId" namespace="" select="fn:string($var37_propertyId)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var39_propertyType)">
																<xsl:attribute name="propertyType" namespace="" select="fn:string($var39_propertyType)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var33_language)">
																<xsl:attribute name="language" namespace="" select="fn:string($var33_language)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var34_isPreferred)">
																<xsl:attribute name="isPreferred" namespace="" select="xs:string(xs:boolean(fn:string($var34_isPreferred)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var41_degreeOfFidelity)">
																<xsl:attribute name="degreeOfFidelity" namespace="" select="fn:string($var41_degreeOfFidelity)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var36_matchIfNoContext)">
																<xsl:attribute name="matchIfNoContext" namespace="" select="xs:string(xs:boolean(fn:string($var36_matchIfNoContext)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var42_representationalForm)">
																<xsl:attribute name="representationalForm" namespace="" select="fn:string($var42_representationalForm)"/>
															</xsl:if>
															<xsl:for-each select="ns1:owner">
																<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:owner>
															</xsl:for-each>
															<xsl:for-each select="ns1:entryState">
																<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf1_entryState">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:entryState>
															</xsl:for-each>
															<xsl:for-each select="ns1:source">
																<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf2_source">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:source>
															</xsl:for-each>
															<xsl:for-each select="ns1:usageContext">
																<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:usageContext>
															</xsl:for-each>
															<xsl:for-each select="ns1:propertyQualifier">
																<xsl:variable name="var44_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																	<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																	<xsl:if test="fn:exists($var44_propertyQualifierType)">
																		<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var44_propertyQualifierType)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var45_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var45_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var45_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:propertyQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns1:value">
																<xsl:variable name="var46_dataType" as="item()*" select="@dataType"/>
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var46_dataType)">
																		<xsl:attribute name="dataType" namespace="" select="fn:string($var46_dataType)"/>
																	</xsl:if>
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:value>
															</xsl:for-each>
														</lgCon:presentation>
													</xsl:for-each>
													<xsl:for-each select="ns2:definition">
														<xsl:variable name="var47_expirationDate" as="item()*" select="@expirationDate"/>
														<xsl:variable name="var48_effectiveDate" as="item()*" select="@effectiveDate"/>
														<xsl:variable name="var49_isActive" as="item()*" select="@isActive"/>
														<xsl:variable name="var50_propertyType" as="item()*" select="@propertyType"/>
														<xsl:variable name="var51_isPreferred" as="item()*" select="@isPreferred"/>
														<xsl:variable name="var52_propertyId" as="item()*" select="@propertyId"/>
														<xsl:variable name="var53_language" as="item()*" select="@language"/>
														<xsl:variable name="var54_status" as="item()*" select="@status"/>
														<lgCon:definition xsl:exclude-result-prefixes="lgCon">
															<xsl:if test="fn:exists($var49_isActive)">
																<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var49_isActive)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var54_status)">
																<xsl:attribute name="status" namespace="" select="fn:string($var54_status)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var48_effectiveDate)">
																<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var48_effectiveDate)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var47_expirationDate)">
																<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var47_expirationDate)))"/>
															</xsl:if>
															<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
															<xsl:if test="fn:exists($var52_propertyId)">
																<xsl:attribute name="propertyId" namespace="" select="fn:string($var52_propertyId)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var50_propertyType)">
																<xsl:attribute name="propertyType" namespace="" select="fn:string($var50_propertyType)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var53_language)">
																<xsl:attribute name="language" namespace="" select="fn:string($var53_language)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var51_isPreferred)">
																<xsl:attribute name="isPreferred" namespace="" select="xs:string(xs:boolean(fn:string($var51_isPreferred)))"/>
															</xsl:if>
															<xsl:for-each select="ns1:owner">
																<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:owner>
															</xsl:for-each>
															<xsl:for-each select="ns1:entryState">
																<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf1_entryState">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:entryState>
															</xsl:for-each>
															<xsl:for-each select="ns1:source">
																<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf2_source">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:source>
															</xsl:for-each>
															<xsl:for-each select="ns1:usageContext">
																<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:usageContext>
															</xsl:for-each>
															<xsl:for-each select="ns1:propertyQualifier">
																<xsl:variable name="var55_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																	<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																	<xsl:if test="fn:exists($var55_propertyQualifierType)">
																		<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var55_propertyQualifierType)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var56_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var56_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var56_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:propertyQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns1:value">
																<xsl:variable name="var57_dataType" as="item()*" select="@dataType"/>
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var57_dataType)">
																		<xsl:attribute name="dataType" namespace="" select="fn:string($var57_dataType)"/>
																	</xsl:if>
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:value>
															</xsl:for-each>
														</lgCon:definition>
													</xsl:for-each>
													<xsl:for-each select="ns2:comment">
														<xsl:variable name="var58_isActive" as="item()*" select="@isActive"/>
														<xsl:variable name="var59_propertyType" as="item()*" select="@propertyType"/>
														<xsl:variable name="var60_propertyId" as="item()*" select="@propertyId"/>
														<xsl:variable name="var61_effectiveDate" as="item()*" select="@effectiveDate"/>
														<xsl:variable name="var62_expirationDate" as="item()*" select="@expirationDate"/>
														<xsl:variable name="var63_language" as="item()*" select="@language"/>
														<xsl:variable name="var64_status" as="item()*" select="@status"/>
														<lgCon:comment xsl:exclude-result-prefixes="lgCon">
															<xsl:if test="fn:exists($var58_isActive)">
																<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var58_isActive)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var64_status)">
																<xsl:attribute name="status" namespace="" select="fn:string($var64_status)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var61_effectiveDate)">
																<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var61_effectiveDate)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var62_expirationDate)">
																<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var62_expirationDate)))"/>
															</xsl:if>
															<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
															<xsl:if test="fn:exists($var60_propertyId)">
																<xsl:attribute name="propertyId" namespace="" select="fn:string($var60_propertyId)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var59_propertyType)">
																<xsl:attribute name="propertyType" namespace="" select="fn:string($var59_propertyType)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var63_language)">
																<xsl:attribute name="language" namespace="" select="fn:string($var63_language)"/>
															</xsl:if>
															<xsl:for-each select="ns1:owner">
																<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:owner>
															</xsl:for-each>
															<xsl:for-each select="ns1:entryState">
																<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf1_entryState">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:entryState>
															</xsl:for-each>
															<xsl:for-each select="ns1:source">
																<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf2_source">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:source>
															</xsl:for-each>
															<xsl:for-each select="ns1:usageContext">
																<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:usageContext>
															</xsl:for-each>
															<xsl:for-each select="ns1:propertyQualifier">
																<xsl:variable name="var65_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																	<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																	<xsl:if test="fn:exists($var65_propertyQualifierType)">
																		<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var65_propertyQualifierType)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var66_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var66_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var66_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:propertyQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns1:value">
																<xsl:variable name="var67_dataType" as="item()*" select="@dataType"/>
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var67_dataType)">
																		<xsl:attribute name="dataType" namespace="" select="fn:string($var67_dataType)"/>
																	</xsl:if>
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:value>
															</xsl:for-each>
														</lgCon:comment>
													</xsl:for-each>
													<xsl:for-each select="ns2:property">
														<xsl:variable name="var68_expirationDate" as="item()*" select="@expirationDate"/>
														<xsl:variable name="var69_language" as="item()*" select="@language"/>
														<xsl:variable name="var70_effectiveDate" as="item()*" select="@effectiveDate"/>
														<xsl:variable name="var71_status" as="item()*" select="@status"/>
														<xsl:variable name="var72_isActive" as="item()*" select="@isActive"/>
														<xsl:variable name="var73_propertyType" as="item()*" select="@propertyType"/>
														<xsl:variable name="var74_propertyId" as="item()*" select="@propertyId"/>
														<lgCon:property xsl:exclude-result-prefixes="lgCon">
															<xsl:if test="fn:exists($var72_isActive)">
																<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var72_isActive)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var71_status)">
																<xsl:attribute name="status" namespace="" select="fn:string($var71_status)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var70_effectiveDate)">
																<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var70_effectiveDate)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var68_expirationDate)">
																<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var68_expirationDate)))"/>
															</xsl:if>
															<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
															<xsl:if test="fn:exists($var74_propertyId)">
																<xsl:attribute name="propertyId" namespace="" select="fn:string($var74_propertyId)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var73_propertyType)">
																<xsl:attribute name="propertyType" namespace="" select="fn:string($var73_propertyType)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var69_language)">
																<xsl:attribute name="language" namespace="" select="fn:string($var69_language)"/>
															</xsl:if>
															<xsl:for-each select="ns1:owner">
																<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:owner>
															</xsl:for-each>
															<xsl:for-each select="ns1:entryState">
																<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf1_entryState">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:entryState>
															</xsl:for-each>
															<xsl:for-each select="ns1:source">
																<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf2_source">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:source>
															</xsl:for-each>
															<xsl:for-each select="ns1:usageContext">
																<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:usageContext>
															</xsl:for-each>
															<xsl:for-each select="ns1:propertyQualifier">
																<xsl:variable name="var75_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																	<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																	<xsl:if test="fn:exists($var75_propertyQualifierType)">
																		<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var75_propertyQualifierType)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var76_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var76_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var76_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:propertyQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns1:value">
																<xsl:variable name="var77_dataType" as="item()*" select="@dataType"/>
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var77_dataType)">
																		<xsl:attribute name="dataType" namespace="" select="fn:string($var77_dataType)"/>
																	</xsl:if>
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:value>
															</xsl:for-each>
														</lgCon:property>
													</xsl:for-each>
													<xsl:for-each select="ns2:propertyLink">
														<lgCon:propertyLink xsl:exclude-result-prefixes="lgCon">
															<xsl:call-template name="tbf:tbf22_propertyLink">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCon:propertyLink>
													</xsl:for-each>
												</lgCon:entity>
											</xsl:for-each>
										</lgCS:entities>
									</xsl:for-each>
									<xsl:for-each select="ns0:relations">
										<xsl:variable name="var78_containerName" as="item()*" select="@containerName"/>
										<lgCS:relations xsl:exclude-result-prefixes="lgCS">
											<xsl:if test="fn:exists($var78_containerName)">
												<xsl:attribute name="containerName" namespace="" select="fn:string($var78_containerName)"/>
											</xsl:if>
											<xsl:for-each select="ns1:entityDescription">
												<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
													<xsl:for-each select="node()[fn:boolean(self::text())]">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</lgCommon:entityDescription>
											</xsl:for-each>
										</lgCS:relations>
									</xsl:for-each>
								</lgCS:codingScheme>
							</xsl:for-each>
						</codingSchemes>
					</xsl:for-each>
					<xsl:for-each select="ns5:valueSetDefinitions">
						<xsl:variable name="var79_mappings" as="node()" select="ns4:mappings"/>
						<valueDomains>
							<lgVD:mappings xsl:exclude-result-prefixes="lgVD">
								<xsl:for-each select="$var79_mappings/ns3:supportedAssociation">
									<xsl:variable name="var80_uri" as="item()*" select="@uri"/>
									<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
										<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
										<xsl:if test="fn:exists($var80_uri)">
											<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var80_uri)))"/>
										</xsl:if>
										<xsl:sequence select="fn:string(.)"/>
									</lgNaming:supportedAssociation>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedAssociationQualifier">
									<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedAssociationQualifier>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedCodingScheme">
									<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedCodingScheme>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedContainerName">
									<lgNaming:supportedContainer xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf5_supportedContainerName">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedContainer>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedContext">
									<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf6_supportedContext">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedContext>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedDataType">
									<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf7_supportedDataType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedDataType>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedDegreeOfFidelity">
									<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedDegreeOfFidelity>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedEntityType">
									<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf9_supportedEntityType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedEntityType>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedHierarchy">
									<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf10_supportedHierarchy">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedHierarchy>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedLanguage">
									<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf11_supportedLanguage">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedLanguage>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedNamespace">
									<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf12_supportedNamespace">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedNamespace>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedProperty">
									<xsl:variable name="var81_uri" as="item()*" select="@uri"/>
									<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
										<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
										<xsl:if test="fn:exists($var81_uri)">
											<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var81_uri)))"/>
										</xsl:if>
										<xsl:sequence select="fn:string(.)"/>
									</lgNaming:supportedProperty>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedPropertyType">
									<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf13_supportedPropertyType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyType>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedPropertyLink">
									<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyLink>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedPropertyQualifier">
									<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyQualifier>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedPropertyQualifierType">
									<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyQualifierType>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedRepresentationalForm">
									<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedRepresentationalForm>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedSortOrder">
									<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf18_supportedSortOrder">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSortOrder>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedSource">
									<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf19_supportedSource">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSource>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedSourceRole">
									<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf20_supportedSourceRole">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSourceRole>
								</xsl:for-each>
								<xsl:for-each select="$var79_mappings/ns3:supportedStatus">
									<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf21_supportedStatus">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedStatus>
								</xsl:for-each>
							</lgVD:mappings>
							<xsl:for-each select="ns4:valueSetDefinition">
								<xsl:variable name="var82_isActive" as="item()*" select="@isActive"/>
								<xsl:variable name="var83_effectiveDate" as="item()*" select="@effectiveDate"/>
								<xsl:variable name="var84_expirationDate" as="item()*" select="@expirationDate"/>
								<xsl:variable name="var85_status" as="item()*" select="@status"/>
								<xsl:variable name="var86_valueSetDefinitionName" as="item()*" select="@valueSetDefinitionName"/>
								<xsl:variable name="var87_defaultCodingScheme" as="item()*" select="@defaultCodingScheme"/>
								<lgVD:valueDomainDefinition xsl:exclude-result-prefixes="lgVD">
									<xsl:if test="fn:exists($var82_isActive)">
										<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var82_isActive)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var85_status)">
										<xsl:attribute name="status" namespace="" select="fn:string($var85_status)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var83_effectiveDate)">
										<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var83_effectiveDate)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var84_expirationDate)">
										<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var84_expirationDate)))"/>
									</xsl:if>
									<xsl:attribute name="valueDomainURI" namespace="" select="xs:string(xs:anyURI(fn:string(@valueSetDefinitionURI)))"/>
									<xsl:if test="fn:exists($var86_valueSetDefinitionName)">
										<xsl:attribute name="valueDomainName" namespace="" select="fn:string($var86_valueSetDefinitionName)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var87_defaultCodingScheme)">
										<xsl:attribute name="defaultCodingScheme" namespace="" select="fn:string($var87_defaultCodingScheme)"/>
									</xsl:if>
									<xsl:for-each select="ns1:owner">
										<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
											<xsl:sequence select="fn:string(.)"/>
										</lgCommon:owner>
									</xsl:for-each>
									<xsl:for-each select="ns1:entryState">
										<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
											<xsl:call-template name="tbf:tbf1_entryState">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</lgCommon:entryState>
									</xsl:for-each>
									<xsl:for-each select="ns1:entityDescription">
										<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
											<xsl:sequence select="fn:string(.)"/>
										</lgCommon:entityDescription>
									</xsl:for-each>
									<xsl:for-each select="ns4:mappings">
										<lgVD:mappings xsl:exclude-result-prefixes="lgVD">
											<xsl:for-each select="ns3:supportedAssociation">
												<xsl:variable name="var88_uri" as="item()*" select="@uri"/>
												<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
													<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
													<xsl:if test="fn:exists($var88_uri)">
														<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var88_uri)))"/>
													</xsl:if>
													<xsl:sequence select="fn:string(.)"/>
												</lgNaming:supportedAssociation>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedAssociationQualifier">
												<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedAssociationQualifier>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedCodingScheme">
												<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedCodingScheme>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedContext">
												<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf6_supportedContext">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedContext>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedDataType">
												<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf7_supportedDataType">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedDataType>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedDegreeOfFidelity">
												<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedDegreeOfFidelity>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedEntityType">
												<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf9_supportedEntityType">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedEntityType>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedHierarchy">
												<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf10_supportedHierarchy">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedHierarchy>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedLanguage">
												<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf11_supportedLanguage">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedLanguage>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedNamespace">
												<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf12_supportedNamespace">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedNamespace>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedProperty">
												<xsl:variable name="var89_uri" as="item()*" select="@uri"/>
												<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
													<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
													<xsl:if test="fn:exists($var89_uri)">
														<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var89_uri)))"/>
													</xsl:if>
													<xsl:sequence select="fn:string(.)"/>
												</lgNaming:supportedProperty>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedPropertyType">
												<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf13_supportedPropertyType">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedPropertyType>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedPropertyLink">
												<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedPropertyLink>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedPropertyQualifier">
												<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedPropertyQualifier>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedPropertyQualifierType">
												<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedPropertyQualifierType>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedRepresentationalForm">
												<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedRepresentationalForm>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedSortOrder">
												<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf18_supportedSortOrder">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedSortOrder>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedSource">
												<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf19_supportedSource">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedSource>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedSourceRole">
												<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf20_supportedSourceRole">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedSourceRole>
											</xsl:for-each>
											<xsl:for-each select="ns3:supportedStatus">
												<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
													<xsl:call-template name="tbf:tbf21_supportedStatus">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgNaming:supportedStatus>
											</xsl:for-each>
										</lgVD:mappings>
									</xsl:for-each>
									<xsl:for-each select="ns4:source">
										<lgVD:source xsl:exclude-result-prefixes="lgVD">
											<xsl:call-template name="tbf:tbf2_source">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</lgVD:source>
									</xsl:for-each>
									<xsl:for-each select="ns4:representsRealmOrContext">
										<lgVD:representsRealmOrContext xsl:exclude-result-prefixes="lgVD">
											<xsl:sequence select="fn:string(.)"/>
										</lgVD:representsRealmOrContext>
									</xsl:for-each>
									<xsl:for-each select="ns4:properties">
										<lgVD:properties xsl:exclude-result-prefixes="lgVD">
											<xsl:for-each select="ns1:property">
												<xsl:variable name="var90_status" as="item()*" select="@status"/>
												<xsl:variable name="var91_propertyType" as="item()*" select="@propertyType"/>
												<xsl:variable name="var92_propertyId" as="item()*" select="@propertyId"/>
												<xsl:variable name="var93_isActive" as="item()*" select="@isActive"/>
												<xsl:variable name="var94_effectiveDate" as="item()*" select="@effectiveDate"/>
												<xsl:variable name="var95_expirationDate" as="item()*" select="@expirationDate"/>
												<xsl:variable name="var96_language" as="item()*" select="@language"/>
												<lgCommon:property xsl:exclude-result-prefixes="lgCommon">
													<xsl:if test="fn:exists($var93_isActive)">
														<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var93_isActive)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var90_status)">
														<xsl:attribute name="status" namespace="" select="fn:string($var90_status)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var94_effectiveDate)">
														<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var94_effectiveDate)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var95_expirationDate)">
														<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var95_expirationDate)))"/>
													</xsl:if>
													<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
													<xsl:if test="fn:exists($var92_propertyId)">
														<xsl:attribute name="propertyId" namespace="" select="fn:string($var92_propertyId)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var91_propertyType)">
														<xsl:attribute name="propertyType" namespace="" select="fn:string($var91_propertyType)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var96_language)">
														<xsl:attribute name="language" namespace="" select="fn:string($var96_language)"/>
													</xsl:if>
													<xsl:for-each select="ns1:owner">
														<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:owner>
													</xsl:for-each>
													<xsl:for-each select="ns1:entryState">
														<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf1_entryState">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:entryState>
													</xsl:for-each>
													<xsl:for-each select="ns1:source">
														<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf2_source">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:source>
													</xsl:for-each>
													<xsl:for-each select="ns1:usageContext">
														<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:usageContext>
													</xsl:for-each>
													<xsl:for-each select="ns1:propertyQualifier">
														<xsl:variable name="var97_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
														<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
															<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
															<xsl:if test="fn:exists($var97_propertyQualifierType)">
																<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var97_propertyQualifierType)"/>
															</xsl:if>
															<xsl:for-each select="ns1:value">
																<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:value>
															</xsl:for-each>
														</lgCommon:propertyQualifier>
													</xsl:for-each>
													<xsl:for-each select="ns1:value">
														<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf23_text">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:value>
													</xsl:for-each>
												</lgCommon:property>
											</xsl:for-each>
										</lgVD:properties>
									</xsl:for-each>
									<xsl:for-each select="ns4:definitionEntry">
										<xsl:variable name="var98_operator" as="item()*" select="@operator"/>
										<lgVD:definitionEntry xsl:exclude-result-prefixes="lgVD">
											<xsl:attribute name="ruleOrder" namespace="" select="xs:string(xs:integer(fn:string(@ruleOrder)))"/>
											<xsl:if test="fn:exists($var98_operator)">
												<xsl:attribute name="operator" namespace="" select="fn:string($var98_operator)"/>
											</xsl:if>
											<xsl:for-each select="ns4:entityReference">
												<lgVD:entityReference xsl:exclude-result-prefixes="lgVD">
													<xsl:call-template name="tbf:tbf24_entityReference">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgVD:entityReference>
											</xsl:for-each>
											<xsl:for-each select="ns4:valueSetDefinitionReference">
												<lgVD:valueDomainReference xsl:exclude-result-prefixes="lgVD">
													<xsl:sequence select="()"/>
												</lgVD:valueDomainReference>
											</xsl:for-each>
											<xsl:for-each select="ns4:codingSchemeReference">
												<lgVD:codingSchemeReference xsl:exclude-result-prefixes="lgVD">
													<xsl:call-template name="tbf:tbf25_codingSchemeReference">
														<xsl:with-param name="input" select="." as="node()"/>
													</xsl:call-template>
												</lgVD:codingSchemeReference>
											</xsl:for-each>
										</lgVD:definitionEntry>
									</xsl:for-each>
								</lgVD:valueDomainDefinition>
							</xsl:for-each>
						</valueDomains>
					</xsl:for-each>
					<xsl:for-each select="ns5:pickListDefinitions">
						<xsl:variable name="var99_mappings" as="node()" select="ns4:mappings"/>
						<pickLists>
							<lgVD:mappings xsl:exclude-result-prefixes="lgVD">
								<xsl:for-each select="$var99_mappings/ns3:supportedAssociation">
									<xsl:variable name="var100_uri" as="item()*" select="@uri"/>
									<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
										<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
										<xsl:if test="fn:exists($var100_uri)">
											<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var100_uri)))"/>
										</xsl:if>
										<xsl:sequence select="fn:string(.)"/>
									</lgNaming:supportedAssociation>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedAssociationQualifier">
									<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedAssociationQualifier>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedCodingScheme">
									<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedCodingScheme>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedContainerName">
									<lgNaming:supportedContainer xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf5_supportedContainerName">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedContainer>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedContext">
									<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf6_supportedContext">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedContext>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedDataType">
									<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf7_supportedDataType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedDataType>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedDegreeOfFidelity">
									<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedDegreeOfFidelity>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedEntityType">
									<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf9_supportedEntityType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedEntityType>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedHierarchy">
									<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf10_supportedHierarchy">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedHierarchy>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedLanguage">
									<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf11_supportedLanguage">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedLanguage>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedNamespace">
									<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf12_supportedNamespace">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedNamespace>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedProperty">
									<xsl:variable name="var101_uri" as="item()*" select="@uri"/>
									<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
										<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
										<xsl:if test="fn:exists($var101_uri)">
											<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var101_uri)))"/>
										</xsl:if>
										<xsl:sequence select="fn:string(.)"/>
									</lgNaming:supportedProperty>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedPropertyType">
									<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf13_supportedPropertyType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyType>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedPropertyLink">
									<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyLink>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedPropertyQualifier">
									<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyQualifier>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedPropertyQualifierType">
									<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedPropertyQualifierType>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedRepresentationalForm">
									<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedRepresentationalForm>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedSortOrder">
									<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf18_supportedSortOrder">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSortOrder>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedSource">
									<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf19_supportedSource">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSource>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedSourceRole">
									<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf20_supportedSourceRole">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedSourceRole>
								</xsl:for-each>
								<xsl:for-each select="$var99_mappings/ns3:supportedStatus">
									<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
										<xsl:call-template name="tbf:tbf21_supportedStatus">
											<xsl:with-param name="input" select="." as="node()"/>
										</xsl:call-template>
									</lgNaming:supportedStatus>
								</xsl:for-each>
							</lgVD:mappings>
							<xsl:for-each select="ns4:pickListDefinition">
								<xsl:variable name="var102_defaultLanguage" as="item()*" select="@defaultLanguage"/>
								<xsl:variable name="var103_effectiveDate" as="item()*" select="@effectiveDate"/>
								<xsl:variable name="var104_defaultEntityCodeNamespace" as="item()*" select="@defaultEntityCodeNamespace"/>
								<xsl:variable name="var105_status" as="item()*" select="@status"/>
								<xsl:variable name="var106_defaultSortOrder" as="item()*" select="@defaultSortOrder"/>
								<xsl:variable name="var107_isActive" as="item()*" select="@isActive"/>
								<xsl:variable name="var108_expirationDate" as="item()*" select="@expirationDate"/>
								<lgVD:pickListDefinition xsl:exclude-result-prefixes="lgVD">
									<xsl:if test="fn:exists($var107_isActive)">
										<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var107_isActive)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var105_status)">
										<xsl:attribute name="status" namespace="" select="fn:string($var105_status)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var103_effectiveDate)">
										<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var103_effectiveDate)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var108_expirationDate)">
										<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var108_expirationDate)))"/>
									</xsl:if>
									<xsl:attribute name="pickListId" namespace="" select="fn:string(@pickListId)"/>
									<xsl:if test="fn:exists($var104_defaultEntityCodeNamespace)">
										<xsl:attribute name="defaultEntityCodeNamespace" namespace="" select="fn:string($var104_defaultEntityCodeNamespace)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var102_defaultLanguage)">
										<xsl:attribute name="defaultLanguage" namespace="" select="fn:string($var102_defaultLanguage)"/>
									</xsl:if>
									<xsl:if test="fn:exists($var106_defaultSortOrder)">
										<xsl:attribute name="defaultSortOrder" namespace="" select="fn:string($var106_defaultSortOrder)"/>
									</xsl:if>
									<xsl:for-each select="ns1:owner">
										<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
											<xsl:sequence select="fn:string(.)"/>
										</lgCommon:owner>
									</xsl:for-each>
									<xsl:for-each select="ns1:entryState">
										<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
											<xsl:call-template name="tbf:tbf1_entryState">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</lgCommon:entryState>
									</xsl:for-each>
									<xsl:for-each select="ns1:entityDescription">
										<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
											<xsl:sequence select="fn:string(.)"/>
										</lgCommon:entityDescription>
									</xsl:for-each>
								</lgVD:pickListDefinition>
							</xsl:for-each>
						</pickLists>
					</xsl:for-each>
					<xsl:for-each select="ns5:editHistory">
						<editHistory>
							<xsl:for-each select="ns5:revision">
								<xsl:variable name="var109_editOrder" as="item()*" select="@editOrder"/>
								<xsl:variable name="var110_revisionDate" as="item()*" select="@revisionDate"/>
								<revision>
									<xsl:attribute name="revisionId" namespace="" select="fn:string(@revisionId)"/>
									<xsl:if test="fn:exists($var110_revisionDate)">
										<xsl:attribute name="revisionDate" namespace="" select="xs:string(xs:dateTime(fn:string($var110_revisionDate)))"/>
									</xsl:if>
									<xsl:if test="fn:exists($var109_editOrder)">
										<xsl:attribute name="editOrder" namespace="" select="xs:string(xs:integer(fn:string($var109_editOrder)))"/>
									</xsl:if>
									<xsl:for-each select="ns1:entityDescription">
										<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
											<xsl:for-each select="node()[fn:boolean(self::text())]">
												<xsl:sequence select="fn:string(.)"/>
											</xsl:for-each>
										</lgCommon:entityDescription>
									</xsl:for-each>
									<xsl:for-each select="ns5:changeAgent">
										<changeAgent>
											<xsl:sequence select="fn:string(.)"/>
										</changeAgent>
									</xsl:for-each>
									<xsl:for-each select="ns5:changeInstructions">
										<xsl:variable name="var111_dataType" as="item()*" select="@dataType"/>
										<changeInstructions>
											<xsl:if test="fn:exists($var111_dataType)">
												<xsl:attribute name="dataType" namespace="" select="fn:string($var111_dataType)"/>
											</xsl:if>
											<xsl:for-each select="node()[fn:boolean(self::text())]">
												<xsl:sequence select="fn:string(.)"/>
											</xsl:for-each>
										</changeInstructions>
									</xsl:for-each>
									<xsl:for-each select="ns5:changedEntry">
										<changedEntry>
											<xsl:for-each select="ns5:changedCodingSchemeEntry">
												<xsl:variable name="var112_status" as="item()*" select="@status"/>
												<xsl:variable name="var113_approxNumConcepts" as="item()*" select="@approxNumConcepts"/>
												<xsl:variable name="var114_defaultLanguage" as="item()*" select="@defaultLanguage"/>
												<xsl:variable name="var115_isActive" as="item()*" select="@isActive"/>
												<xsl:variable name="var116_effectiveDate" as="item()*" select="@effectiveDate"/>
												<xsl:variable name="var117_expirationDate" as="item()*" select="@expirationDate"/>
												<xsl:variable name="var118_formalName" as="item()*" select="@formalName"/>
												<xsl:variable name="var119_mappings" as="node()" select="ns0:mappings"/>
												<changedCodingSchemeEntry>
													<xsl:if test="fn:exists($var115_isActive)">
														<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var115_isActive)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var112_status)">
														<xsl:attribute name="status" namespace="" select="fn:string($var112_status)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var116_effectiveDate)">
														<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var116_effectiveDate)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var117_expirationDate)">
														<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var117_expirationDate)))"/>
													</xsl:if>
													<xsl:attribute name="codingSchemeName" namespace="" select="fn:string(@codingSchemeName)"/>
													<xsl:attribute name="codingSchemeURI" namespace="" select="xs:string(xs:anyURI(fn:string(@codingSchemeURI)))"/>
													<xsl:if test="fn:exists($var118_formalName)">
														<xsl:attribute name="formalName" namespace="" select="fn:string($var118_formalName)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var114_defaultLanguage)">
														<xsl:attribute name="defaultLanguage" namespace="" select="fn:string($var114_defaultLanguage)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var113_approxNumConcepts)">
														<xsl:attribute name="approxNumConcepts" namespace="" select="xs:string(xs:integer(fn:string($var113_approxNumConcepts)))"/>
													</xsl:if>
													<xsl:attribute name="representsVersion" namespace="" select="fn:string(@representsVersion)"/>
													<xsl:for-each select="ns1:owner">
														<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:owner>
													</xsl:for-each>
													<xsl:for-each select="ns1:entryState">
														<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf1_entryState">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:entryState>
													</xsl:for-each>
													<xsl:for-each select="ns1:entityDescription">
														<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
															<xsl:for-each select="node()[fn:boolean(self::text())]">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</lgCommon:entityDescription>
													</xsl:for-each>
													<xsl:for-each select="ns0:localName">
														<lgCS:localName xsl:exclude-result-prefixes="lgCS">
															<xsl:sequence select="fn:string(.)"/>
														</lgCS:localName>
													</xsl:for-each>
													<xsl:for-each select="ns0:source">
														<lgCS:source xsl:exclude-result-prefixes="lgCS">
															<xsl:call-template name="tbf:tbf2_source">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCS:source>
													</xsl:for-each>
													<xsl:for-each select="ns0:copyright">
														<xsl:variable name="var120_dataType" as="item()*" select="@dataType"/>
														<lgCS:copyright xsl:exclude-result-prefixes="lgCS">
															<xsl:if test="fn:exists($var120_dataType)">
																<xsl:attribute name="dataType" namespace="" select="fn:string($var120_dataType)"/>
															</xsl:if>
															<xsl:for-each select="node()[fn:boolean(self::text())]">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</lgCS:copyright>
													</xsl:for-each>
													<lgCS:mappings xsl:exclude-result-prefixes="lgCS">
														<xsl:for-each select="$var119_mappings/ns3:supportedAssociation">
															<xsl:variable name="var121_uri" as="item()*" select="@uri"/>
															<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
																<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
																<xsl:if test="fn:exists($var121_uri)">
																	<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var121_uri)))"/>
																</xsl:if>
																<xsl:sequence select="fn:string(.)"/>
															</lgNaming:supportedAssociation>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedAssociationQualifier">
															<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedAssociationQualifier>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedCodingScheme">
															<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedCodingScheme>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedContext">
															<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf6_supportedContext">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedContext>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedDataType">
															<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf7_supportedDataType">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedDataType>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedDegreeOfFidelity">
															<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedDegreeOfFidelity>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedEntityType">
															<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf9_supportedEntityType">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedEntityType>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedHierarchy">
															<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf10_supportedHierarchy">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedHierarchy>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedLanguage">
															<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf11_supportedLanguage">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedLanguage>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedNamespace">
															<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf12_supportedNamespace">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedNamespace>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedProperty">
															<xsl:variable name="var122_uri" as="item()*" select="@uri"/>
															<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
																<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
																<xsl:if test="fn:exists($var122_uri)">
																	<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var122_uri)))"/>
																</xsl:if>
																<xsl:sequence select="fn:string(.)"/>
															</lgNaming:supportedProperty>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedPropertyType">
															<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf13_supportedPropertyType">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedPropertyType>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedPropertyLink">
															<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedPropertyLink>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedPropertyQualifier">
															<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedPropertyQualifier>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedPropertyQualifierType">
															<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedPropertyQualifierType>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedRepresentationalForm">
															<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedRepresentationalForm>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedSortOrder">
															<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf18_supportedSortOrder">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedSortOrder>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedSource">
															<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf19_supportedSource">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedSource>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedSourceRole">
															<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf20_supportedSourceRole">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedSourceRole>
														</xsl:for-each>
														<xsl:for-each select="$var119_mappings/ns3:supportedStatus">
															<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
																<xsl:call-template name="tbf:tbf21_supportedStatus">
																	<xsl:with-param name="input" select="." as="node()"/>
																</xsl:call-template>
															</lgNaming:supportedStatus>
														</xsl:for-each>
													</lgCS:mappings>
													<xsl:for-each select="ns0:properties">
														<lgCS:properties xsl:exclude-result-prefixes="lgCS">
															<xsl:for-each select="ns1:property">
																<xsl:variable name="var123_status" as="item()*" select="@status"/>
																<xsl:variable name="var124_propertyType" as="item()*" select="@propertyType"/>
																<xsl:variable name="var125_isActive" as="item()*" select="@isActive"/>
																<xsl:variable name="var126_propertyId" as="item()*" select="@propertyId"/>
																<xsl:variable name="var127_effectiveDate" as="item()*" select="@effectiveDate"/>
																<xsl:variable name="var128_expirationDate" as="item()*" select="@expirationDate"/>
																<xsl:variable name="var129_language" as="item()*" select="@language"/>
																<lgCommon:property xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var125_isActive)">
																		<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var125_isActive)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var123_status)">
																		<xsl:attribute name="status" namespace="" select="fn:string($var123_status)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var127_effectiveDate)">
																		<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var127_effectiveDate)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var128_expirationDate)">
																		<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var128_expirationDate)))"/>
																	</xsl:if>
																	<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																	<xsl:if test="fn:exists($var126_propertyId)">
																		<xsl:attribute name="propertyId" namespace="" select="fn:string($var126_propertyId)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var124_propertyType)">
																		<xsl:attribute name="propertyType" namespace="" select="fn:string($var124_propertyType)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var129_language)">
																		<xsl:attribute name="language" namespace="" select="fn:string($var129_language)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:owner">
																		<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCommon:owner>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:entryState">
																		<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																			<xsl:call-template name="tbf:tbf1_entryState">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCommon:entryState>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:source">
																		<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																			<xsl:call-template name="tbf:tbf2_source">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCommon:source>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:usageContext">
																		<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCommon:usageContext>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:propertyQualifier">
																		<xsl:variable name="var130_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																		<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																			<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																			<xsl:if test="fn:exists($var130_propertyQualifierType)">
																				<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var130_propertyQualifierType)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var131_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var131_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var131_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCommon:propertyQualifier>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var132_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var132_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var132_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:property>
															</xsl:for-each>
														</lgCS:properties>
													</xsl:for-each>
													<xsl:for-each select="ns0:entities">
														<lgCS:entities xsl:exclude-result-prefixes="lgCS">
															<xsl:for-each select="ns2:entity">
																<xsl:variable name="var133_entityCodeNamespace" as="item()*" select="@entityCodeNamespace"/>
																<xsl:variable name="var134_status" as="item()*" select="@status"/>
																<xsl:variable name="var135_isAnonymous" as="item()*" select="@isAnonymous"/>
																<xsl:variable name="var136_isDefined" as="item()*" select="@isDefined"/>
																<xsl:variable name="var137_isActive" as="item()*" select="@isActive"/>
																<xsl:variable name="var138_effectiveDate" as="item()*" select="@effectiveDate"/>
																<xsl:variable name="var139_expirationDate" as="item()*" select="@expirationDate"/>
																<lgCon:entity xsl:exclude-result-prefixes="lgCon">
																	<xsl:if test="fn:exists($var137_isActive)">
																		<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var137_isActive)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var134_status)">
																		<xsl:attribute name="status" namespace="" select="fn:string($var134_status)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var138_effectiveDate)">
																		<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var138_effectiveDate)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var139_expirationDate)">
																		<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var139_expirationDate)))"/>
																	</xsl:if>
																	<xsl:attribute name="entityCode" namespace="" select="fn:string(@entityCode)"/>
																	<xsl:if test="fn:exists($var133_entityCodeNamespace)">
																		<xsl:attribute name="entityCodeNamespace" namespace="" select="fn:string($var133_entityCodeNamespace)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var135_isAnonymous)">
																		<xsl:attribute name="isAnonymous" namespace="" select="xs:string(xs:boolean(fn:string($var135_isAnonymous)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var136_isDefined)">
																		<xsl:attribute name="isDefined" namespace="" select="xs:string(xs:boolean(fn:string($var136_isDefined)))"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:owner">
																		<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCommon:owner>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:entryState">
																		<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																			<xsl:call-template name="tbf:tbf1_entryState">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCommon:entryState>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:entityDescription">
																		<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:entityDescription>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:entityType">
																		<lgCon:entityType xsl:exclude-result-prefixes="lgCon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCon:entityType>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:presentation">
																		<xsl:variable name="var140_representationalForm" as="item()*" select="@representationalForm"/>
																		<xsl:variable name="var141_matchIfNoContext" as="item()*" select="@matchIfNoContext"/>
																		<xsl:variable name="var142_degreeOfFidelity" as="item()*" select="@degreeOfFidelity"/>
																		<xsl:variable name="var143_propertyType" as="item()*" select="@propertyType"/>
																		<xsl:variable name="var144_propertyId" as="item()*" select="@propertyId"/>
																		<xsl:variable name="var145_isActive" as="item()*" select="@isActive"/>
																		<xsl:variable name="var146_effectiveDate" as="item()*" select="@effectiveDate"/>
																		<xsl:variable name="var147_expirationDate" as="item()*" select="@expirationDate"/>
																		<xsl:variable name="var148_language" as="item()*" select="@language"/>
																		<xsl:variable name="var149_isPreferred" as="item()*" select="@isPreferred"/>
																		<xsl:variable name="var150_status" as="item()*" select="@status"/>
																		<lgCon:presentation xsl:exclude-result-prefixes="lgCon">
																			<xsl:if test="fn:exists($var145_isActive)">
																				<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var145_isActive)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var150_status)">
																				<xsl:attribute name="status" namespace="" select="fn:string($var150_status)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var146_effectiveDate)">
																				<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var146_effectiveDate)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var147_expirationDate)">
																				<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var147_expirationDate)))"/>
																			</xsl:if>
																			<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																			<xsl:if test="fn:exists($var144_propertyId)">
																				<xsl:attribute name="propertyId" namespace="" select="fn:string($var144_propertyId)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var143_propertyType)">
																				<xsl:attribute name="propertyType" namespace="" select="fn:string($var143_propertyType)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var148_language)">
																				<xsl:attribute name="language" namespace="" select="fn:string($var148_language)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var149_isPreferred)">
																				<xsl:attribute name="isPreferred" namespace="" select="xs:string(xs:boolean(fn:string($var149_isPreferred)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var142_degreeOfFidelity)">
																				<xsl:attribute name="degreeOfFidelity" namespace="" select="fn:string($var142_degreeOfFidelity)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var141_matchIfNoContext)">
																				<xsl:attribute name="matchIfNoContext" namespace="" select="xs:string(xs:boolean(fn:string($var141_matchIfNoContext)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var140_representationalForm)">
																				<xsl:attribute name="representationalForm" namespace="" select="fn:string($var140_representationalForm)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:owner">
																				<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:owner>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:entryState">
																				<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf1_entryState">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:entryState>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:source">
																				<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf2_source">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:source>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:usageContext">
																				<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:usageContext>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:propertyQualifier">
																				<xsl:variable name="var151_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																				<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																					<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																					<xsl:if test="fn:exists($var151_propertyQualifierType)">
																						<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var151_propertyQualifierType)"/>
																					</xsl:if>
																					<xsl:for-each select="ns1:value">
																						<xsl:variable name="var152_dataType" as="item()*" select="@dataType"/>
																						<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																							<xsl:if test="fn:exists($var152_dataType)">
																								<xsl:attribute name="dataType" namespace="" select="fn:string($var152_dataType)"/>
																							</xsl:if>
																							<xsl:for-each select="node()[fn:boolean(self::text())]">
																								<xsl:sequence select="fn:string(.)"/>
																							</xsl:for-each>
																						</lgCommon:value>
																					</xsl:for-each>
																				</lgCommon:propertyQualifier>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var153_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var153_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var153_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCon:presentation>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:definition">
																		<xsl:variable name="var154_propertyType" as="item()*" select="@propertyType"/>
																		<xsl:variable name="var155_isActive" as="item()*" select="@isActive"/>
																		<xsl:variable name="var156_propertyId" as="item()*" select="@propertyId"/>
																		<xsl:variable name="var157_effectiveDate" as="item()*" select="@effectiveDate"/>
																		<xsl:variable name="var158_language" as="item()*" select="@language"/>
																		<xsl:variable name="var159_isPreferred" as="item()*" select="@isPreferred"/>
																		<xsl:variable name="var160_expirationDate" as="item()*" select="@expirationDate"/>
																		<xsl:variable name="var161_status" as="item()*" select="@status"/>
																		<lgCon:definition xsl:exclude-result-prefixes="lgCon">
																			<xsl:if test="fn:exists($var155_isActive)">
																				<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var155_isActive)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var161_status)">
																				<xsl:attribute name="status" namespace="" select="fn:string($var161_status)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var157_effectiveDate)">
																				<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var157_effectiveDate)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var160_expirationDate)">
																				<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var160_expirationDate)))"/>
																			</xsl:if>
																			<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																			<xsl:if test="fn:exists($var156_propertyId)">
																				<xsl:attribute name="propertyId" namespace="" select="fn:string($var156_propertyId)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var154_propertyType)">
																				<xsl:attribute name="propertyType" namespace="" select="fn:string($var154_propertyType)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var158_language)">
																				<xsl:attribute name="language" namespace="" select="fn:string($var158_language)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var159_isPreferred)">
																				<xsl:attribute name="isPreferred" namespace="" select="xs:string(xs:boolean(fn:string($var159_isPreferred)))"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:owner">
																				<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:owner>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:entryState">
																				<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf1_entryState">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:entryState>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:source">
																				<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf2_source">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:source>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:usageContext">
																				<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:usageContext>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:propertyQualifier">
																				<xsl:variable name="var162_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																				<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																					<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																					<xsl:if test="fn:exists($var162_propertyQualifierType)">
																						<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var162_propertyQualifierType)"/>
																					</xsl:if>
																					<xsl:for-each select="ns1:value">
																						<xsl:variable name="var163_dataType" as="item()*" select="@dataType"/>
																						<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																							<xsl:if test="fn:exists($var163_dataType)">
																								<xsl:attribute name="dataType" namespace="" select="fn:string($var163_dataType)"/>
																							</xsl:if>
																							<xsl:for-each select="node()[fn:boolean(self::text())]">
																								<xsl:sequence select="fn:string(.)"/>
																							</xsl:for-each>
																						</lgCommon:value>
																					</xsl:for-each>
																				</lgCommon:propertyQualifier>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var164_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var164_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var164_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCon:definition>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:comment">
																		<xsl:variable name="var165_status" as="item()*" select="@status"/>
																		<xsl:variable name="var166_propertyType" as="item()*" select="@propertyType"/>
																		<xsl:variable name="var167_propertyId" as="item()*" select="@propertyId"/>
																		<xsl:variable name="var168_effectiveDate" as="item()*" select="@effectiveDate"/>
																		<xsl:variable name="var169_expirationDate" as="item()*" select="@expirationDate"/>
																		<xsl:variable name="var170_language" as="item()*" select="@language"/>
																		<xsl:variable name="var171_isActive" as="item()*" select="@isActive"/>
																		<lgCon:comment xsl:exclude-result-prefixes="lgCon">
																			<xsl:if test="fn:exists($var171_isActive)">
																				<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var171_isActive)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var165_status)">
																				<xsl:attribute name="status" namespace="" select="fn:string($var165_status)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var168_effectiveDate)">
																				<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var168_effectiveDate)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var169_expirationDate)">
																				<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var169_expirationDate)))"/>
																			</xsl:if>
																			<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																			<xsl:if test="fn:exists($var167_propertyId)">
																				<xsl:attribute name="propertyId" namespace="" select="fn:string($var167_propertyId)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var166_propertyType)">
																				<xsl:attribute name="propertyType" namespace="" select="fn:string($var166_propertyType)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var170_language)">
																				<xsl:attribute name="language" namespace="" select="fn:string($var170_language)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:owner">
																				<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:owner>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:entryState">
																				<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf1_entryState">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:entryState>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:source">
																				<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf2_source">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:source>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:usageContext">
																				<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:usageContext>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:propertyQualifier">
																				<xsl:variable name="var172_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																				<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																					<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																					<xsl:if test="fn:exists($var172_propertyQualifierType)">
																						<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var172_propertyQualifierType)"/>
																					</xsl:if>
																					<xsl:for-each select="ns1:value">
																						<xsl:variable name="var173_dataType" as="item()*" select="@dataType"/>
																						<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																							<xsl:if test="fn:exists($var173_dataType)">
																								<xsl:attribute name="dataType" namespace="" select="fn:string($var173_dataType)"/>
																							</xsl:if>
																							<xsl:for-each select="node()[fn:boolean(self::text())]">
																								<xsl:sequence select="fn:string(.)"/>
																							</xsl:for-each>
																						</lgCommon:value>
																					</xsl:for-each>
																				</lgCommon:propertyQualifier>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var174_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var174_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var174_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCon:comment>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:property">
																		<xsl:variable name="var175_isActive" as="item()*" select="@isActive"/>
																		<xsl:variable name="var176_effectiveDate" as="item()*" select="@effectiveDate"/>
																		<xsl:variable name="var177_propertyType" as="item()*" select="@propertyType"/>
																		<xsl:variable name="var178_status" as="item()*" select="@status"/>
																		<xsl:variable name="var179_propertyId" as="item()*" select="@propertyId"/>
																		<xsl:variable name="var180_language" as="item()*" select="@language"/>
																		<xsl:variable name="var181_expirationDate" as="item()*" select="@expirationDate"/>
																		<lgCon:property xsl:exclude-result-prefixes="lgCon">
																			<xsl:if test="fn:exists($var175_isActive)">
																				<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var175_isActive)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var178_status)">
																				<xsl:attribute name="status" namespace="" select="fn:string($var178_status)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var176_effectiveDate)">
																				<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var176_effectiveDate)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var181_expirationDate)">
																				<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var181_expirationDate)))"/>
																			</xsl:if>
																			<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																			<xsl:if test="fn:exists($var179_propertyId)">
																				<xsl:attribute name="propertyId" namespace="" select="fn:string($var179_propertyId)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var177_propertyType)">
																				<xsl:attribute name="propertyType" namespace="" select="fn:string($var177_propertyType)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var180_language)">
																				<xsl:attribute name="language" namespace="" select="fn:string($var180_language)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:owner">
																				<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:owner>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:entryState">
																				<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf1_entryState">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:entryState>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:source">
																				<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf2_source">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:source>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:usageContext">
																				<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:usageContext>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:propertyQualifier">
																				<xsl:variable name="var182_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																				<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																					<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																					<xsl:if test="fn:exists($var182_propertyQualifierType)">
																						<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var182_propertyQualifierType)"/>
																					</xsl:if>
																					<xsl:for-each select="ns1:value">
																						<xsl:variable name="var183_dataType" as="item()*" select="@dataType"/>
																						<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																							<xsl:if test="fn:exists($var183_dataType)">
																								<xsl:attribute name="dataType" namespace="" select="fn:string($var183_dataType)"/>
																							</xsl:if>
																							<xsl:for-each select="node()[fn:boolean(self::text())]">
																								<xsl:sequence select="fn:string(.)"/>
																							</xsl:for-each>
																						</lgCommon:value>
																					</xsl:for-each>
																				</lgCommon:propertyQualifier>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var184_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var184_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var184_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCon:property>
																	</xsl:for-each>
																	<xsl:for-each select="ns2:propertyLink">
																		<lgCon:propertyLink xsl:exclude-result-prefixes="lgCon">
																			<xsl:call-template name="tbf:tbf22_propertyLink">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCon:propertyLink>
																	</xsl:for-each>
																</lgCon:entity>
															</xsl:for-each>
														</lgCS:entities>
													</xsl:for-each>
													<xsl:for-each select="ns0:relations">
														<xsl:variable name="var185_containerName" as="item()*" select="@containerName"/>
														<lgCS:relations xsl:exclude-result-prefixes="lgCS">
															<xsl:if test="fn:exists($var185_containerName)">
																<xsl:attribute name="containerName" namespace="" select="fn:string($var185_containerName)"/>
															</xsl:if>
															<xsl:for-each select="ns1:entityDescription">
																<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
																	<xsl:for-each select="node()[fn:boolean(self::text())]">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</lgCommon:entityDescription>
															</xsl:for-each>
														</lgCS:relations>
													</xsl:for-each>
												</changedCodingSchemeEntry>
											</xsl:for-each>
											<xsl:for-each select="ns5:changedPickListDefinitionEntry">
												<xsl:variable name="var186_status" as="item()*" select="@status"/>
												<xsl:variable name="var187_isActive" as="item()*" select="@isActive"/>
												<xsl:variable name="var188_defaultSortOrder" as="item()*" select="@defaultSortOrder"/>
												<xsl:variable name="var189_effectiveDate" as="item()*" select="@effectiveDate"/>
												<xsl:variable name="var190_expirationDate" as="item()*" select="@expirationDate"/>
												<xsl:variable name="var191_defaultLanguage" as="item()*" select="@defaultLanguage"/>
												<xsl:variable name="var192_defaultEntityCodeNamespace" as="item()*" select="@defaultEntityCodeNamespace"/>
												<changedPickListDefinitionEntry>
													<xsl:if test="fn:exists($var187_isActive)">
														<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var187_isActive)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var186_status)">
														<xsl:attribute name="status" namespace="" select="fn:string($var186_status)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var189_effectiveDate)">
														<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var189_effectiveDate)))"/>
													</xsl:if>
													<xsl:if test="fn:exists($var190_expirationDate)">
														<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var190_expirationDate)))"/>
													</xsl:if>
													<xsl:attribute name="pickListId" namespace="" select="fn:string(@pickListId)"/>
													<xsl:if test="fn:exists($var192_defaultEntityCodeNamespace)">
														<xsl:attribute name="defaultEntityCodeNamespace" namespace="" select="fn:string($var192_defaultEntityCodeNamespace)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var191_defaultLanguage)">
														<xsl:attribute name="defaultLanguage" namespace="" select="fn:string($var191_defaultLanguage)"/>
													</xsl:if>
													<xsl:if test="fn:exists($var188_defaultSortOrder)">
														<xsl:attribute name="defaultSortOrder" namespace="" select="fn:string($var188_defaultSortOrder)"/>
													</xsl:if>
													<xsl:for-each select="ns1:owner">
														<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
															<xsl:sequence select="fn:string(.)"/>
														</lgCommon:owner>
													</xsl:for-each>
													<xsl:for-each select="ns1:entryState">
														<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
															<xsl:call-template name="tbf:tbf1_entryState">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgCommon:entryState>
													</xsl:for-each>
													<xsl:for-each select="ns1:entityDescription">
														<lgCommon:entityDescription xsl:exclude-result-prefixes="lgCommon">
															<xsl:for-each select="node()[fn:boolean(self::text())]">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</lgCommon:entityDescription>
													</xsl:for-each>
													<xsl:for-each select="ns4:mappings">
														<lgVD:mappings xsl:exclude-result-prefixes="lgVD">
															<xsl:for-each select="ns3:supportedAssociation">
																<xsl:variable name="var193_uri" as="item()*" select="@uri"/>
																<lgNaming:supportedAssociation xsl:exclude-result-prefixes="lgNaming">
																	<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
																	<xsl:if test="fn:exists($var193_uri)">
																		<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var193_uri)))"/>
																	</xsl:if>
																	<xsl:sequence select="fn:string(.)"/>
																</lgNaming:supportedAssociation>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedAssociationQualifier">
																<lgNaming:supportedAssociationQualifier xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf3_supportedAssociationQualifier">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedAssociationQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedCodingScheme">
																<lgNaming:supportedCodingScheme xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf4_supportedCodingScheme">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedCodingScheme>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedContext">
																<lgNaming:supportedContext xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf6_supportedContext">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedContext>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedDataType">
																<lgNaming:supportedDataType xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf7_supportedDataType">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedDataType>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedDegreeOfFidelity">
																<lgNaming:supportedDegreeOfFidelity xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf8_supportedDegreeOfFidelity">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedDegreeOfFidelity>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedEntityType">
																<lgNaming:supportedEntityType xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf9_supportedEntityType">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedEntityType>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedHierarchy">
																<lgNaming:supportedHierarchy xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf10_supportedHierarchy">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedHierarchy>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedLanguage">
																<lgNaming:supportedLanguage xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf11_supportedLanguage">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedLanguage>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedNamespace">
																<lgNaming:supportedNamespace xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf12_supportedNamespace">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedNamespace>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedProperty">
																<xsl:variable name="var194_uri" as="item()*" select="@uri"/>
																<lgNaming:supportedProperty xsl:exclude-result-prefixes="lgNaming">
																	<xsl:attribute name="localId" namespace="" select="fn:string(@localId)"/>
																	<xsl:if test="fn:exists($var194_uri)">
																		<xsl:attribute name="uri" namespace="" select="xs:string(xs:anyURI(fn:string($var194_uri)))"/>
																	</xsl:if>
																	<xsl:sequence select="fn:string(.)"/>
																</lgNaming:supportedProperty>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedPropertyType">
																<lgNaming:supportedPropertyType xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf13_supportedPropertyType">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedPropertyType>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedPropertyLink">
																<lgNaming:supportedPropertyLink xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf14_supportedPropertyLink">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedPropertyLink>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedPropertyQualifier">
																<lgNaming:supportedPropertyQualifier xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf15_supportedPropertyQualifier">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedPropertyQualifier>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedPropertyQualifierType">
																<lgNaming:supportedPropertyQualifierType xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf16_supportedPropertyQualifierType">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedPropertyQualifierType>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedRepresentationalForm">
																<lgNaming:supportedRepresentationalForm xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf17_supportedRepresentationalForm">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedRepresentationalForm>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedSortOrder">
																<lgNaming:supportedSortOrder xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf18_supportedSortOrder">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedSortOrder>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedSource">
																<lgNaming:supportedSource xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf19_supportedSource">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedSource>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedSourceRole">
																<lgNaming:supportedSourceRole xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf20_supportedSourceRole">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedSourceRole>
															</xsl:for-each>
															<xsl:for-each select="ns3:supportedStatus">
																<lgNaming:supportedStatus xsl:exclude-result-prefixes="lgNaming">
																	<xsl:call-template name="tbf:tbf21_supportedStatus">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgNaming:supportedStatus>
															</xsl:for-each>
														</lgVD:mappings>
													</xsl:for-each>
													<xsl:for-each select="ns4:pickListEntryNode">
														<xsl:variable name="var195_isActive" as="item()*" select="@isActive"/>
														<xsl:variable name="var196_effectiveDate" as="item()*" select="@effectiveDate"/>
														<xsl:variable name="var197_expirationDate" as="item()*" select="@expirationDate"/>
														<xsl:variable name="var198_status" as="item()*" select="@status"/>
														<lgVD:pickListEntryNode xsl:exclude-result-prefixes="lgVD">
															<xsl:if test="fn:exists($var195_isActive)">
																<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var195_isActive)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var198_status)">
																<xsl:attribute name="status" namespace="" select="fn:string($var198_status)"/>
															</xsl:if>
															<xsl:if test="fn:exists($var196_effectiveDate)">
																<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var196_effectiveDate)))"/>
															</xsl:if>
															<xsl:if test="fn:exists($var197_expirationDate)">
																<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var197_expirationDate)))"/>
															</xsl:if>
															<xsl:attribute name="pickListEntryId" namespace="" select="fn:string(@pickListEntryId)"/>
															<xsl:for-each select="ns1:owner">
																<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																	<xsl:sequence select="fn:string(.)"/>
																</lgCommon:owner>
															</xsl:for-each>
															<xsl:for-each select="ns1:entryState">
																<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																	<xsl:call-template name="tbf:tbf1_entryState">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgCommon:entryState>
															</xsl:for-each>
															<xsl:for-each select="ns4:exclusionEntry">
																<lgVD:exclusionEntry xsl:exclude-result-prefixes="lgVD">
																	<xsl:call-template name="tbf:tbf26_pickListEntryExclusion">
																		<xsl:with-param name="input" select="." as="node()"/>
																	</xsl:call-template>
																</lgVD:exclusionEntry>
															</xsl:for-each>
															<xsl:for-each select="ns4:inclusionEntry">
																<xsl:variable name="var199_isDefault" as="item()*" select="@isDefault"/>
																<xsl:variable name="var200_entityCodeNamespace" as="item()*" select="@entityCodeNamespace"/>
																<xsl:variable name="var201_matchIfNoContext" as="item()*" select="@matchIfNoContext"/>
																<xsl:variable name="var202_propertyId" as="item()*" select="@propertyId"/>
																<xsl:variable name="var203_language" as="item()*" select="@language"/>
																<xsl:variable name="var204_entryOrder" as="item()*" select="@entryOrder"/>
																<lgVD:inclusionEntry xsl:exclude-result-prefixes="lgVD">
																	<xsl:if test="fn:exists($var204_entryOrder)">
																		<xsl:attribute name="entryOrder" namespace="" select="xs:string(xs:integer(fn:string($var204_entryOrder)))"/>
																	</xsl:if>
																	<xsl:attribute name="entityCode" namespace="" select="fn:string(@entityCode)"/>
																	<xsl:if test="fn:exists($var200_entityCodeNamespace)">
																		<xsl:attribute name="entityCodeNamespace" namespace="" select="fn:string($var200_entityCodeNamespace)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var202_propertyId)">
																		<xsl:attribute name="propertyId" namespace="" select="fn:string($var202_propertyId)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var199_isDefault)">
																		<xsl:attribute name="isDefault" namespace="" select="xs:string(xs:boolean(fn:string($var199_isDefault)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var201_matchIfNoContext)">
																		<xsl:attribute name="matchIfNoContext" namespace="" select="xs:string(xs:boolean(fn:string($var201_matchIfNoContext)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var203_language)">
																		<xsl:attribute name="language" namespace="" select="fn:string($var203_language)"/>
																	</xsl:if>
																	<lgVD:pickText xsl:exclude-result-prefixes="lgVD">
																		<xsl:sequence select="fn:string(ns4:pickText)"/>
																	</lgVD:pickText>
																	<xsl:for-each select="ns4:pickContext">
																		<lgVD:pickContext xsl:exclude-result-prefixes="lgVD">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgVD:pickContext>
																	</xsl:for-each>
																</lgVD:inclusionEntry>
															</xsl:for-each>
															<xsl:for-each select="ns4:properties">
																<lgVD:properties xsl:exclude-result-prefixes="lgVD">
																	<xsl:for-each select="ns1:property">
																		<xsl:variable name="var205_propertyId" as="item()*" select="@propertyId"/>
																		<xsl:variable name="var206_effectiveDate" as="item()*" select="@effectiveDate"/>
																		<xsl:variable name="var207_expirationDate" as="item()*" select="@expirationDate"/>
																		<xsl:variable name="var208_language" as="item()*" select="@language"/>
																		<xsl:variable name="var209_isActive" as="item()*" select="@isActive"/>
																		<xsl:variable name="var210_status" as="item()*" select="@status"/>
																		<xsl:variable name="var211_propertyType" as="item()*" select="@propertyType"/>
																		<lgCommon:property xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var209_isActive)">
																				<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var209_isActive)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var210_status)">
																				<xsl:attribute name="status" namespace="" select="fn:string($var210_status)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var206_effectiveDate)">
																				<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var206_effectiveDate)))"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var207_expirationDate)">
																				<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var207_expirationDate)))"/>
																			</xsl:if>
																			<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																			<xsl:if test="fn:exists($var205_propertyId)">
																				<xsl:attribute name="propertyId" namespace="" select="fn:string($var205_propertyId)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var211_propertyType)">
																				<xsl:attribute name="propertyType" namespace="" select="fn:string($var211_propertyType)"/>
																			</xsl:if>
																			<xsl:if test="fn:exists($var208_language)">
																				<xsl:attribute name="language" namespace="" select="fn:string($var208_language)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:owner">
																				<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:owner>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:entryState">
																				<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf1_entryState">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:entryState>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:source">
																				<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																					<xsl:call-template name="tbf:tbf2_source">
																						<xsl:with-param name="input" select="." as="node()"/>
																					</xsl:call-template>
																				</lgCommon:source>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:usageContext">
																				<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																					<xsl:sequence select="fn:string(.)"/>
																				</lgCommon:usageContext>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:propertyQualifier">
																				<xsl:variable name="var212_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																				<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																					<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																					<xsl:if test="fn:exists($var212_propertyQualifierType)">
																						<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var212_propertyQualifierType)"/>
																					</xsl:if>
																					<xsl:for-each select="ns1:value">
																						<xsl:variable name="var213_dataType" as="item()*" select="@dataType"/>
																						<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																							<xsl:if test="fn:exists($var213_dataType)">
																								<xsl:attribute name="dataType" namespace="" select="fn:string($var213_dataType)"/>
																							</xsl:if>
																							<xsl:for-each select="node()[fn:boolean(self::text())]">
																								<xsl:sequence select="fn:string(.)"/>
																							</xsl:for-each>
																						</lgCommon:value>
																					</xsl:for-each>
																				</lgCommon:propertyQualifier>
																			</xsl:for-each>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var214_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var214_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var214_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCommon:property>
																	</xsl:for-each>
																</lgVD:properties>
															</xsl:for-each>
														</lgVD:pickListEntryNode>
													</xsl:for-each>
													<xsl:for-each select="ns4:source">
														<lgVD:source xsl:exclude-result-prefixes="lgVD">
															<xsl:call-template name="tbf:tbf2_source">
																<xsl:with-param name="input" select="." as="node()"/>
															</xsl:call-template>
														</lgVD:source>
													</xsl:for-each>
													<xsl:for-each select="ns4:defaultPickContext">
														<lgVD:defaultPickContext xsl:exclude-result-prefixes="lgVD">
															<xsl:sequence select="fn:string(.)"/>
														</lgVD:defaultPickContext>
													</xsl:for-each>
													<xsl:for-each select="ns4:properties">
														<lgVD:properties xsl:exclude-result-prefixes="lgVD">
															<xsl:for-each select="ns1:property">
																<xsl:variable name="var215_expirationDate" as="item()*" select="@expirationDate"/>
																<xsl:variable name="var216_effectiveDate" as="item()*" select="@effectiveDate"/>
																<xsl:variable name="var217_propertyType" as="item()*" select="@propertyType"/>
																<xsl:variable name="var218_propertyId" as="item()*" select="@propertyId"/>
																<xsl:variable name="var219_isActive" as="item()*" select="@isActive"/>
																<xsl:variable name="var220_status" as="item()*" select="@status"/>
																<xsl:variable name="var221_language" as="item()*" select="@language"/>
																<lgCommon:property xsl:exclude-result-prefixes="lgCommon">
																	<xsl:if test="fn:exists($var219_isActive)">
																		<xsl:attribute name="isActive" namespace="" select="xs:string(xs:boolean(fn:string($var219_isActive)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var220_status)">
																		<xsl:attribute name="status" namespace="" select="fn:string($var220_status)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var216_effectiveDate)">
																		<xsl:attribute name="effectiveDate" namespace="" select="xs:string(xs:dateTime(fn:string($var216_effectiveDate)))"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var215_expirationDate)">
																		<xsl:attribute name="expirationDate" namespace="" select="xs:string(xs:dateTime(fn:string($var215_expirationDate)))"/>
																	</xsl:if>
																	<xsl:attribute name="propertyName" namespace="" select="fn:string(@propertyName)"/>
																	<xsl:if test="fn:exists($var218_propertyId)">
																		<xsl:attribute name="propertyId" namespace="" select="fn:string($var218_propertyId)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var217_propertyType)">
																		<xsl:attribute name="propertyType" namespace="" select="fn:string($var217_propertyType)"/>
																	</xsl:if>
																	<xsl:if test="fn:exists($var221_language)">
																		<xsl:attribute name="language" namespace="" select="fn:string($var221_language)"/>
																	</xsl:if>
																	<xsl:for-each select="ns1:owner">
																		<lgCommon:owner xsl:exclude-result-prefixes="lgCommon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCommon:owner>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:entryState">
																		<lgCommon:entryState xsl:exclude-result-prefixes="lgCommon">
																			<xsl:call-template name="tbf:tbf1_entryState">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCommon:entryState>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:source">
																		<lgCommon:source xsl:exclude-result-prefixes="lgCommon">
																			<xsl:call-template name="tbf:tbf2_source">
																				<xsl:with-param name="input" select="." as="node()"/>
																			</xsl:call-template>
																		</lgCommon:source>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:usageContext">
																		<lgCommon:usageContext xsl:exclude-result-prefixes="lgCommon">
																			<xsl:sequence select="fn:string(.)"/>
																		</lgCommon:usageContext>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:propertyQualifier">
																		<xsl:variable name="var222_propertyQualifierType" as="item()*" select="@propertyQualifierType"/>
																		<lgCommon:propertyQualifier xsl:exclude-result-prefixes="lgCommon">
																			<xsl:attribute name="propertyQualifierName" namespace="" select="fn:string(@propertyQualifierName)"/>
																			<xsl:if test="fn:exists($var222_propertyQualifierType)">
																				<xsl:attribute name="propertyQualifierType" namespace="" select="fn:string($var222_propertyQualifierType)"/>
																			</xsl:if>
																			<xsl:for-each select="ns1:value">
																				<xsl:variable name="var223_dataType" as="item()*" select="@dataType"/>
																				<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																					<xsl:if test="fn:exists($var223_dataType)">
																						<xsl:attribute name="dataType" namespace="" select="fn:string($var223_dataType)"/>
																					</xsl:if>
																					<xsl:for-each select="node()[fn:boolean(self::text())]">
																						<xsl:sequence select="fn:string(.)"/>
																					</xsl:for-each>
																				</lgCommon:value>
																			</xsl:for-each>
																		</lgCommon:propertyQualifier>
																	</xsl:for-each>
																	<xsl:for-each select="ns1:value">
																		<xsl:variable name="var224_dataType" as="item()*" select="@dataType"/>
																		<lgCommon:value xsl:exclude-result-prefixes="lgCommon">
																			<xsl:if test="fn:exists($var224_dataType)">
																				<xsl:attribute name="dataType" namespace="" select="fn:string($var224_dataType)"/>
																			</xsl:if>
																			<xsl:for-each select="node()[fn:boolean(self::text())]">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</lgCommon:value>
																	</xsl:for-each>
																</lgCommon:property>
															</xsl:for-each>
														</lgVD:properties>
													</xsl:for-each>
												</changedPickListDefinitionEntry>
											</xsl:for-each>
										</changedEntry>
									</xsl:for-each>
								</revision>
							</xsl:for-each>
						</editHistory>
					</xsl:for-each>
				</xsl:for-each>
			</systemRelease>
		</xsl:variable>
		<xsl:variable name="var1_resultof_convert_uri_to_windows_file_path" as="xs:string">
			<xsl:call-template name="core:convert-uri-to-windows-file-path">
				<xsl:with-param name="uri" select="fn:document-uri(.)" as="xs:string"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:result-document href="{$var1_resultof_convert_uri_to_windows_file_path}" encoding="UTF-8">
			<xsl:sequence select="$var225_let"/>
		</xsl:result-document>
	</xsl:template>
</xsl:stylesheet>
