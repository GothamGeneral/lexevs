package org.LexGrid.LexBIG.Impl.loaders;import java.net.URI;import org.LexGrid.LexBIG.DataModel.InterfaceElements.ExtensionDescription;import org.LexGrid.LexBIG.Exceptions.LBInvocationException;import org.LexGrid.LexBIG.Exceptions.LBParameterException;import org.LexGrid.LexBIG.Extensions.Load.MedDRA_Loader;import org.LexGrid.LexBIG.Extensions.Load.OntologyFormat;import org.LexGrid.LexBIG.Extensions.Load.options.OptionHolder;import org.LexGrid.codingSchemes.CodingScheme;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRA2LGMain;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRAFormatValidator;import edu.mayo.informatics.lexgrid.convert.utility.URNVersionPair;public class MedDRALoaderImpl extends BaseLoader implements MedDRA_Loader {    private static final long serialVersionUID = 8418561158634673381L;    public MedDRALoaderImpl() {        super();        this.setDoApplyPostLoadManifest(false);    }    @Override    public String getMedDRAVersion() {        return "1.0";    }    // TODO: Uncertain what should be in this method    protected ExtensionDescription buildExtensionDescription(){        ExtensionDescription temp = new ExtensionDescription();        temp.setExtensionBaseClass(MedDRALoaderImpl.class.getInterfaces()[0].getName());        temp.setExtensionClass(MedDRALoaderImpl.class.getName());        temp.setDescription(description);        temp.setName(name);        temp.setVersion( getMedDRAVersion() );        return temp;    }    @Override    public void validate(URI sourceDir, int validationLevel) throws LBParameterException {        try {            setInUse();            if (!MedDRAFormatValidator.isValidDirecotry(sourceDir)) {                throw new LBParameterException("The MedDRA file header was  malformed while validating  "+ sourceDir);            }            if (!MedDRAFormatValidator.allMedDRAfilesExist(sourceDir)) {                throw new LBParameterException("Not all required MedDRA files exist in directory provide: "+ sourceDir);            }            if (!MedDRAFormatValidator.allMedDRAfilesValid(sourceDir)) {                throw new LBParameterException("At least one MedDRA file content was malformed while validating "+ sourceDir);            }        } catch (Exception e) {            throw new LBParameterException(e.getMessage());        } finally {            inUse = false;        }    }    @Override    public void load(URI uri, boolean stopOnErrors, boolean async) throws LBParameterException,            LBInvocationException {        this.getOptions().getBooleanOption(FAIL_ON_ERROR_OPTION).setOptionValue(stopOnErrors);        this.getOptions().getBooleanOption(ASYNC_OPTION).setOptionValue(async);                this.load(uri);    }    @Override    protected OptionHolder declareAllowedOptions(OptionHolder holder) {        return holder;    }    @Override    protected URNVersionPair[] doLoad() throws Exception {              MedDRA2LGMain mainTxfm = new MedDRA2LGMain();        try{            CodingScheme codingScheme = mainTxfm.map(this.getResourceUri(), this.getMessageDirector());              return null;//            this.persistCodingSchemeToDatabase(codingScheme);//            return this.constructVersionPairsFromCodingSchemes(codingScheme);        } catch (Exception e) {            throw new RuntimeException(e);        }    }            @Override    public OntologyFormat getOntologyFormat() {        return OntologyFormat.MEDDRA;    }}