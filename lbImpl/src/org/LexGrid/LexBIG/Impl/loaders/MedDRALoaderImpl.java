package org.LexGrid.LexBIG.Impl.loaders;import java.net.URI;import java.util.List;import org.LexGrid.LexBIG.DataModel.InterfaceElements.ExtensionDescription;import org.LexGrid.LexBIG.Exceptions.LBInvocationException;import org.LexGrid.LexBIG.Exceptions.LBParameterException;import org.LexGrid.LexBIG.Extensions.Load.MedDRA_Loader;import org.LexGrid.LexBIG.Extensions.Load.OntologyFormat;import org.LexGrid.LexBIG.Extensions.Load.options.OptionHolder;import org.LexGrid.LexBIG.Utility.logging.LgMessageDirectorIF;import org.LexGrid.codingSchemes.CodingScheme;import org.lexevs.logging.messaging.impl.CachingMessageDirectorImpl;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRA2LGMain;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRAFormatValidator;import edu.mayo.informatics.lexgrid.convert.utility.URNVersionPair;public class MedDRALoaderImpl extends BaseLoader implements MedDRA_Loader {    private static final long serialVersionUID = 8418561158634673381L;    public MedDRALoaderImpl() {        super();        this.setDoApplyPostLoadManifest(false);    }    @Override    public String getMedDRAVersion() {        return "1.0";    }    @Override    protected ExtensionDescription buildExtensionDescription(){        ExtensionDescription temp = new ExtensionDescription();        temp.setExtensionBaseClass(MedDRALoaderImpl.class.getInterfaces()[0].getName());        temp.setExtensionClass(MedDRALoaderImpl.class.getName());        temp.setDescription(description);        temp.setName(name);        temp.setVersion( getMedDRAVersion() );        return temp;    }    @Override    public void validate(URI sourceDir, int validationLevel) throws LBParameterException {        String message;        try {            setInUse();            if (!MedDRAFormatValidator.isValidDirecotry(sourceDir)) {                throw new LBParameterException("The MedDRA file header was  malformed while validating  "+ sourceDir);            }                        List<String> missingFiles = MedDRAFormatValidator.allMedDRAfilesExist(sourceDir);            if (missingFiles.size() > 0) {                message = "Following MedDRA files are missing: \n";                for(int i=0; i < missingFiles.size(); i++){                    message += message + missingFiles.get(i) + "\n";                }                throw new LBParameterException(message);            }                        List<String> invalidFiles = MedDRAFormatValidator.allMedDRAfilesValid(sourceDir);             if (invalidFiles.size() > 0) {                message = "Following MedDRA files have invalid data: \n";                for(int i=0; i < invalidFiles.size(); i++){                    message += message + invalidFiles.get(i) + "\n";                }                throw new LBParameterException(message);            }        } catch (Exception e) {            throw new LBParameterException(e.getMessage());        } finally {            inUse = false;        }    }    @Override    public void load(URI uri, boolean stopOnErrors, boolean async) throws LBParameterException,            LBInvocationException {        this.getOptions().getBooleanOption(FAIL_ON_ERROR_OPTION).setOptionValue(stopOnErrors);        this.getOptions().getBooleanOption(ASYNC_OPTION).setOptionValue(async);                this.load(uri);    }    @Override    protected OptionHolder declareAllowedOptions(OptionHolder holder) {        holder.setIsResourceUriFolder(true);                return holder;    }    @Override    protected URNVersionPair[] doLoad() throws Exception {        LgMessageDirectorIF messages = new CachingMessageDirectorImpl(this.getMessageDirector());        MedDRA2LGMain mainTxfm = new MedDRA2LGMain();        try{            CodingScheme codingScheme = mainTxfm.map(this.getResourceUri(), this.getMessageDirector());              messages.info("Completed mapping.  Now saving to database");            this.persistCodingSchemeToDatabase(codingScheme);                          //            this.buildRootNode(//                    Constructors.createAbsoluteCodingSchemeVersionReference(//                    codingScheme.getCodingSchemeURI(), codingScheme.getRepresentsVersion()), //                    Arrays.asList(MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE), //                    getRelationsContainerName(codingScheme), //                    RootOrTail.ROOT,//                    TraverseAssociations.INDIVIDUALLY);                                                messages.info("Saved to database.  Now constructing version pairs");                        return this.constructVersionPairsFromCodingSchemes(codingScheme);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    //    private String getRelationsContainerName(CodingScheme codingScheme) {//        Relations[] relations = codingScheme.getRelations();//        Assert.state(relations.length == 1);//        //        return relations[0].getContainerName();//    }        @Override    public OntologyFormat getOntologyFormat() {        return OntologyFormat.MEDDRA;    }}