package edu.mayo.informatics.lexgrid.convert.directConversions.medDRA;import java.io.FileNotFoundException;import java.io.FileReader;import java.lang.reflect.Field;import java.net.URI;import java.util.ArrayList;import java.util.Hashtable;import java.util.List;import org.LexGrid.LexBIG.Utility.logging.LgMessageDirectorIF;import org.LexGrid.codingSchemes.CodingScheme;import org.LexGrid.commonTypes.EntityDescription;import org.LexGrid.commonTypes.Text;import org.LexGrid.concepts.Entities;import org.LexGrid.concepts.Entity;import org.LexGrid.naming.Mappings;import org.LexGrid.naming.SupportedCodingScheme;import org.LexGrid.naming.SupportedHierarchy;import org.LexGrid.naming.SupportedLanguage;import org.lexevs.logging.messaging.impl.CachingMessageDirectorImpl;import au.com.bytecode.opencsv.CSVReader;import au.com.bytecode.opencsv.bean.ColumnPositionMappingStrategy;import au.com.bytecode.opencsv.bean.CsvToBean;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRA2LGConstants.MedDRA_METADATA;public class MedDRAMapToLexGrid {    private static MedDRA_METADATA [] meddraMetaData = MedDRA_METADATA.values();    private LgMessageDirectorIF messages_;    private URI medDRASourceDir;    private Database meddraDatabase;    private Hashtable<Integer, Entity> internalIdToEntityHash;        public MedDRAMapToLexGrid(URI inFileName, LgMessageDirectorIF lg_messages) {        this.messages_ = new CachingMessageDirectorImpl(lg_messages);        this.medDRASourceDir = inFileName;        meddraDatabase = new Database();    }    public void readMedDRAFiles() {        try{            this.createDatabase();        } catch (Exception e) {            messages_.error("Failed to read MedDRA data files, check connection values");            e.printStackTrace();        }    }        public void mapToLexGrid(CodingScheme csclass){        try {            loadCodingScheme(csclass);//            loadAssociationEntityAndSupportedMaps(csclass);             loadConcepts(csclass);//            loadPresentations();//            loadDefinitions();//            loadConceptProperties();             loadRelations(csclass, internalIdToEntityHash);        } catch (Exception e) {            messages_.error("Failed to connect to RIM Database, check connection values");            e.printStackTrace();        }            }    private void loadRelations(CodingScheme csclass, Hashtable<Integer, Entity> internalIdToEntityHash2) {        messages_.info("Loading all relations properties");            }    private void loadConcepts(CodingScheme csclass) {        messages_.info("Loading concepts");        Entities concepts = csclass.getEntities();        if (concepts == null) {            concepts = new Entities();            csclass.setEntities(concepts);        }        //        loadArtificialTopNodes(csclass, concepts);          }//    private void loadConceptProperties() {//        messages_.info("Loading all concept properties");//    }////    private void loadDefinitions() {//        messages_.info("Loading all definitions");//        //    }////    private void loadPresentations() {//        messages_.info("Loading all presentations");//        //    }////    private void loadAssociationEntityAndSupportedMaps(CodingScheme csclass) {//        messages_.info("Loading AssociationEntityAndSupportedMaps");//        //    }    private void loadCodingScheme(CodingScheme csclass) {        try {            messages_.info("Loading coding scheme information");            // Determine which bean contains coding scheme info            String name = MedDRA2LGConstants.DEFAULT_NAME;            csclass.setCodingSchemeName(name);            csclass.setCodingSchemeURI(MedDRA2LGConstants.DEFAULT_URN);            csclass.setFormalName(MedDRA2LGConstants.DEFAULT_FORMAL_NAME);            EntityDescription enDesc = new EntityDescription();            enDesc.setContent(MedDRA2LGConstants.DEFAULT_ENTITY_DESCRIPTION);            csclass.setEntityDescription(enDesc);            csclass.setDefaultLanguage(MedDRA2LGConstants.DEFAULT_LANGUAGE_EN);            String version = this.getVersion();            csclass.setRepresentsVersion(version);                        Text txt = new Text();            txt.setContent(MedDRA2LGConstants.DEFAULT_COPYRIGHT);            csclass.setCopyright(txt);            csclass.setMappings(new Mappings());                        // Add SupportedCodingScheme and SupportedLanguage Mappings            SupportedCodingScheme scs = new SupportedCodingScheme();            scs.setLocalId(csclass.getCodingSchemeName());            scs.setUri(csclass.getCodingSchemeURI());            csclass.getMappings().addSupportedCodingScheme(scs);            SupportedLanguage lang = new SupportedLanguage();            lang.setLocalId(MedDRA2LGConstants.DEFAULT_LANGUAGE_EN);            csclass.getMappings().addSupportedLanguage(lang);                        // Add SupportedHierarchy Mappings            SupportedHierarchy hierarchy = new SupportedHierarchy();            hierarchy.setLocalId(MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE);            ArrayList<String> list = new ArrayList<String>();            list.add(MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE);            hierarchy.setAssociationNames(list);            hierarchy.setRootCode(MedDRA2LGConstants.DEFAULT_ROOT_NODE);            hierarchy.setIsForwardNavigable(true);            csclass.getMappings().addSupportedHierarchy(hierarchy);                        hierarchy = new SupportedHierarchy();            hierarchy.setLocalId(MedDRA2LGConstants.ASSOCIATION_IS_A);            list = new ArrayList<String>();            list.add(MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE);            hierarchy.setAssociationNames(list);            hierarchy.setRootCode(MedDRA2LGConstants.DEFAULT_ROOT_NODE);            hierarchy.setIsForwardNavigable(true);            csclass.getMappings().addSupportedHierarchy(hierarchy);               } catch (Exception e) {            messages_.error("Failed while preparing MedDRA Coding Scheme Class", e);            e.printStackTrace();        }     }    private String getVersion() {        String version = null;        List<DatabaseRecord> records = meddraDatabase.get(MedDRA_METADATA.RELEASE.classname().getName());        if(records.size() == 1){            version = ((MedDRA_record_meddra_release) records.get(0)).getVersion();        }        return version;    }    public Database createDatabase(){        String input;                for(int i=0; i < meddraMetaData.length; i++){            input = medDRASourceDir.getPath() + meddraMetaData[i].filename();            try {                FileReader fileReader = new FileReader(input);                CSVReader reader = new CSVReader(fileReader, '$');                ColumnPositionMappingStrategy<DatabaseRecord> strat = new ColumnPositionMappingStrategy<DatabaseRecord>();                strat.setType(meddraMetaData[i].classname());                String[] columns = getFields(meddraMetaData[i].classname());                             strat.setColumnMapping(columns);                    CsvToBean<DatabaseRecord> csv = new CsvToBean<DatabaseRecord>();                List<DatabaseRecord> list = csv.parse(strat, reader);                meddraDatabase.add(meddraMetaData[i].classname().getName(), list);            } catch (FileNotFoundException e) {                e.printStackTrace();            }        }                return meddraDatabase;    }    private String[] getFields(Class<?> class1) {        Field [] fields = class1.getDeclaredFields();           String [] fieldnames = new String[fields.length - 1];                for(int i=1; i < fields.length; i++){            fieldnames[i-1] = fields[i].getName();        }        return fieldnames;    }//    void loadArtificialTopNodes(CodingScheme csclass, Entities concepts) {//        messages_.info("Processing code systems into top nodes");//        ResultSet topNode_results = null;//        try {//            // Create an "@" top node.//            Entity rootNode = new Entity();////            // Create and set the concept code for "@"//            String topNodeDesignation = "@";//            rootNode.setEntityCode(topNodeDesignation);//            rootNode.setEntityCodeNamespace(csclass.getCodingSchemeName());//            rootNode.setIsAnonymous(Boolean.TRUE);//            EntityDescription enDesc = new EntityDescription();//            enDesc.setContent("Root node for subclass relations.");//            rootNode.setEntityDescription(enDesc);//            concepts.addEntity(rootNode);////            AssociationSource ai = new AssociationSource();//            ai.setSourceEntityCode(rootNode.getEntityCode());//            ai.setSourceEntityCodeNamespace(csclass.getCodingSchemeName());//            AssociationPredicate parent_assoc = (AssociationPredicate) RelationsUtil//                    .resolveAssociationPredicates(csclass, MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE).get(0);//            ai = RelationsUtil.subsume(parent_assoc, ai);////            // Get all the code systems from database object//            List<DatabaseRecord> dataResults = meddraDatabase.get(MedDRA_METADATA.LOW_LEVEL_TERM.classname().getName());//            //            for(DatabaseRecord data : dataResults){//                MedDRA_record_llt record = (MedDRA_record_llt) data;//                Entity topNode = new Entity();//                String nodeName = record.getLlt_name();  //dataResults.getString("codeSystemName");//                String entityDescription = record.getFullName(); // dataResults.getString("fullName");//                String oid = record.getLlt_code(); //dataResults.getString("codeSystemId");//                String def = record.getDescription();  // dataResults.getString("description");//                String internalId= record.getInternalID(); //dataResults.getString("internalId");//               //                if (StringUtils.isNotBlank(internalId)) {//                    topNode.setEntityCode(internalId + ":" + nodeName);                   //                } else {//                    topNode.setEntityCode(nodeName + ":" + nodeName);//                }//                topNode.setEntityCodeNamespace(csclass.getCodingSchemeName());////                EntityDescription enD = new EntityDescription();//                enD.setContent(entityDescription);//                topNode.setEntityDescription(enD);//                topNode.setIsActive(true);////                // Set presentation so it's a full fledged concept//                Presentation p = new Presentation();//                Text txt = new Text();//                txt.setContent((String) entityDescription);//                p.setValue(txt);//                p.setIsPreferred(Boolean.TRUE);//                p.setPropertyName(MedDRA2LGConstants.PROPERTY_PRINTNAME);//                p.setPropertyId("T1");//                p.setLanguage(MedDRA2LGConstants.DEFAULT_LANGUAGE_EN);//                topNode.addPresentation(p);////                // Set definition//                if (StringUtils.isNotBlank(def)) {//                    Definition definition = new Definition();//                    Text defText = new Text();//                    defText.setContent(def);//                    definition.setValue(defText);//                    definition.setPropertyName(MedDRA2LGConstants.PROPERTY_DEFINITION);//                    definition.setPropertyId("D1");//                    definition.setIsActive(Boolean.TRUE);//                    definition.setIsPreferred(Boolean.TRUE);//                    definition.setLanguage(MedDRA2LGConstants.DEFAULT_LANGUAGE_EN);//                    topNode.addDefinition(definition);//                }//                //                topNode.addEntityType( EntityTypes.CONCEPT.toString());//                concepts.addEntity(topNode);////                // This coding scheme is attached to an artificial root.//                AssociationTarget at = new AssociationTarget();//                at.setTargetEntityCode(topNode.getEntityCode());//                at.setTargetEntityCodeNamespace(csclass.getCodingSchemeName());//                RelationsUtil.subsume(ai, at);////                // Now find the top nodes of the scheme and subsume them to this//                // scheme's artificial top node.//                // First get a list of all nodes in the scheme.//                // but again exclude the code system nodes.//                ArrayList<String> topNodes = new ArrayList<String>();//////                // Drop any from the list that aren't top nodes.//                ArrayList<String> nodesToRemove = new ArrayList<String>();//                PreparedStatement checkForTopNode = null;//                for (int i = 0; i < topNodes.size(); i++) {//                    checkForTopNode = c//                            .prepareStatement("SELECT targetInternalId FROM VCS_concept_relationship WHERE targetInternalId =?");//                    checkForTopNode.setString(1, (String) topNodes.get(i));//                    topNode_results = checkForTopNode.executeQuery();//                    if (topNode_results.next()) {//                        if (topNodes.get(i).equals(topNode_results.getString(1))) {//                            nodesToRemove.add(topNodes.get(i));//                        }//                    }//                    if (topNode_results != null)//                        topNode_results.close();//                    if (checkForTopNode != null)//                        checkForTopNode.close();//                }////                for (int i = 0; i < nodesToRemove.size(); i++) {//                    topNodes.remove(nodesToRemove.get(i));//                }//                // Get the full concept code for each.//                PreparedStatement getconceptSuffix = null;//                ResultSet conceptCode = null;//                for (int i = 0; i < topNodes.size(); i++) {//                    getconceptSuffix = c//                            .prepareStatement("SELECT conceptCode2 FROM VCS_concept_code_xref where internalId = ?");////                    getconceptSuffix.setString(1, (String) topNodes.get(i));//                    conceptCode = getconceptSuffix.executeQuery();//                    conceptCode.next();//                    topNodes.set(i, topNodes.get(i) + ":" + conceptCode.getString(1));//                    if (conceptCode != null)//                        conceptCode.close();//                    if (getconceptSuffix != null)//                        getconceptSuffix.close();//                }////                // For each top node subsume to the current artificial node for//                // the scheme.//                for (int j = 0; j < topNodes.size(); j++) {//                    try {//                        AssociationSource atn = new AssociationSource();//                        atn.setSourceEntityCode(topNode.getEntityCode());//                        atn.setSourceEntityCodeNamespace(csclass.getCodingSchemeName());//                        atn = RelationsUtil.subsume(parent_assoc, atn);////                        AssociationTarget atopNode = new AssociationTarget();//                        atopNode.setTargetEntityCode((String) topNodes.get(j));//                        atopNode.setTargetEntityCodeNamespace(csclass.getCodingSchemeName());//                        RelationsUtil.subsume(atn, atopNode);//                    } catch (Exception e) {//                        messages_.error("Failed while processing HL7 psuedo top node hierarchy", e);//                        e.printStackTrace();//                    }//                }//            }//            dataResults.close();//            messages_.info("Top node processing complete");//        } catch (Exception e) {//            messages_.error("Top node processing failed", e);//            e.printStackTrace();//        }////    }}